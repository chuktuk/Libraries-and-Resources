"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2019, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var algorithm_1 = require("@lumino/algorithm");
var selectionmodel_1 = require("./selectionmodel");
/**
 * A basic selection model implementation.
 *
 * #### Notes
 * This selection model is sufficient for most use cases where
 * structural knowledge of the data source is *not* required.
 */
var BasicSelectionModel = /** @class */ (function (_super) {
    __extends(BasicSelectionModel, _super);
    function BasicSelectionModel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._cursorRow = -1;
        _this._cursorColumn = -1;
        _this._cursorRectIndex = -1;
        _this._selections = [];
        return _this;
    }
    Object.defineProperty(BasicSelectionModel.prototype, "isEmpty", {
        /**
         * Wether the selection model is empty.
         */
        get: function () {
            return this._selections.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasicSelectionModel.prototype, "cursorRow", {
        /**
         * The row index of the cursor.
         */
        get: function () {
            return this._cursorRow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasicSelectionModel.prototype, "cursorColumn", {
        /**
         * The column index of the cursor.
         */
        get: function () {
            return this._cursorColumn;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Move cursor down/up/left/right while making sure it remains
     * within the bounds of selected rectangles
     *
     * @param direction - The direction of the movement.
     */
    BasicSelectionModel.prototype.moveCursorWithinSelections = function (direction) {
        var _this = this;
        // Bail early if there are no selections or no existing cursor
        if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {
            return;
        }
        // Bail early if only single cell is selected
        var firstSelection = this._selections[0];
        if (this._selections.length === 1 &&
            firstSelection.r1 === firstSelection.r2 &&
            firstSelection.c1 === firstSelection.c2) {
            return;
        }
        // start from last selection rectangle
        if (this._cursorRectIndex === -1) {
            this._cursorRectIndex = this._selections.length - 1;
        }
        var cursorRect = this._selections[this._cursorRectIndex];
        var dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;
        var dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;
        var newRow = this._cursorRow + dr;
        var newColumn = this._cursorColumn + dc;
        var r1 = Math.min(cursorRect.r1, cursorRect.r2);
        var r2 = Math.max(cursorRect.r1, cursorRect.r2);
        var c1 = Math.min(cursorRect.c1, cursorRect.c2);
        var c2 = Math.max(cursorRect.c1, cursorRect.c2);
        var moveToNextRect = function () {
            _this._cursorRectIndex = (_this._cursorRectIndex + 1) % _this._selections.length;
            cursorRect = _this._selections[_this._cursorRectIndex];
            newRow = Math.min(cursorRect.r1, cursorRect.r2);
            newColumn = Math.min(cursorRect.c1, cursorRect.c2);
        };
        var moveToPreviousRect = function () {
            _this._cursorRectIndex = _this._cursorRectIndex === 0 ? _this._selections.length - 1 : _this._cursorRectIndex - 1;
            cursorRect = _this._selections[_this._cursorRectIndex];
            newRow = Math.max(cursorRect.r1, cursorRect.r2);
            newColumn = Math.max(cursorRect.c1, cursorRect.c2);
        };
        if (newRow > r2) {
            newRow = r1;
            newColumn += 1;
            if (newColumn > c2) {
                moveToNextRect();
            }
        }
        else if (newRow < r1) {
            newRow = r2;
            newColumn -= 1;
            if (newColumn < c1) {
                moveToPreviousRect();
            }
        }
        else if (newColumn > c2) {
            newColumn = c1;
            newRow += 1;
            if (newRow > r2) {
                moveToNextRect();
            }
        }
        else if (newColumn < c1) {
            newColumn = c2;
            newRow -= 1;
            if (newRow < r1) {
                moveToPreviousRect();
            }
        }
        this._cursorRow = newRow;
        this._cursorColumn = newColumn;
        // Emit the changed signal.
        this.emitChanged();
    };
    /**
     * Get the current selection in the selection model.
     *
     * @returns The current selection or `null`.
     *
     * #### Notes
     * This is the selection which holds the cursor.
     */
    BasicSelectionModel.prototype.currentSelection = function () {
        return this._selections[this._selections.length - 1] || null;
    };
    /**
     * Get an iterator of the selections in the model.
     *
     * @returns A new iterator of the current selections.
     *
     * #### Notes
     * The data grid will render the selections in order.
     */
    BasicSelectionModel.prototype.selections = function () {
        return algorithm_1.iter(this._selections);
    };
    /**
     * Select the specified cells.
     *
     * @param args - The arguments for the selection.
     */
    BasicSelectionModel.prototype.select = function (args) {
        // Fetch the current row and column counts;
        var rowCount = this.dataModel.rowCount('body');
        var columnCount = this.dataModel.columnCount('body');
        // Bail early if there is no content.
        if (rowCount <= 0 || columnCount <= 0) {
            return;
        }
        // Unpack the arguments.
        var r1 = args.r1, c1 = args.c1, r2 = args.r2, c2 = args.c2, cursorRow = args.cursorRow, cursorColumn = args.cursorColumn, clear = args.clear;
        // Clear the necessary selections.
        if (clear === 'all') {
            this._selections.length = 0;
        }
        else if (clear === 'current') {
            this._selections.pop();
        }
        // Clamp to the data model bounds.
        r1 = Math.max(0, Math.min(r1, rowCount - 1));
        r2 = Math.max(0, Math.min(r2, rowCount - 1));
        c1 = Math.max(0, Math.min(c1, columnCount - 1));
        c2 = Math.max(0, Math.min(c2, columnCount - 1));
        // Handle the selection mode.
        if (this.selectionMode === 'row') {
            c1 = 0;
            c2 = columnCount - 1;
        }
        else if (this.selectionMode === 'column') {
            r1 = 0;
            r2 = rowCount - 1;
        }
        // Alias the cursor row and column.
        var cr = cursorRow;
        var cc = cursorColumn;
        // Compute the new cursor location.
        if (cr < 0 || (cr < r1 && cr < r2) || (cr > r1 && cr > r2)) {
            cr = r1;
        }
        if (cc < 0 || (cc < c1 && cc < c2) || (cc > c1 && cc > c2)) {
            cc = c1;
        }
        // Update the cursor.
        this._cursorRow = cr;
        this._cursorColumn = cc;
        this._cursorRectIndex = this._selections.length;
        // Add the new selection.
        this._selections.push({ r1: r1, c1: c1, r2: r2, c2: c2 });
        // Emit the changed signal.
        this.emitChanged();
    };
    /**
     * Clear all selections in the selection model.
     */
    BasicSelectionModel.prototype.clear = function () {
        // Bail early if there are no selections.
        if (this._selections.length === 0) {
            return;
        }
        // Reset the internal state.
        this._cursorRow = -1;
        this._cursorColumn = -1;
        this._cursorRectIndex = -1;
        this._selections.length = 0;
        // Emit the changed signal.
        this.emitChanged();
    };
    /**
     * A signal handler for the data model `changed` signal.
     *
     * @param args - The arguments for the signal.
     */
    BasicSelectionModel.prototype.onDataModelChanged = function (sender, args) {
        // Bail early if the model has no current selections.
        if (this._selections.length === 0) {
            return;
        }
        // Bail early if the cells have changed in place.
        if (args.type === 'cells-changed') {
            return;
        }
        // Bail early if there is no change to the row or column count.
        if (args.type === 'rows-moved' || args.type === 'columns-moved') {
            return;
        }
        // Fetch the last row and column index.
        var lr = sender.rowCount('body') - 1;
        var lc = sender.columnCount('body') - 1;
        // Bail early if the data model is empty.
        if (lr < 0 || lc < 0) {
            this._selections.length = 0;
            this.emitChanged();
            return;
        }
        // Fetch the selection mode.
        var mode = this.selectionMode;
        // Set up the assignment index variable.
        var j = 0;
        // Iterate over the current selections.
        for (var i = 0, n = this._selections.length; i < n; ++i) {
            // Unpack the selection.
            var _a = this._selections[i], r1 = _a.r1, c1 = _a.c1, r2 = _a.r2, c2 = _a.c2;
            // Skip the selection if it will disappear.
            if ((lr < r1 && lr < r2) || (lc < c1 && lc < c2)) {
                continue;
            }
            // Modify the bounds based on the selection mode.
            if (mode === 'row') {
                r1 = Math.max(0, Math.min(r1, lr));
                r2 = Math.max(0, Math.min(r2, lr));
                c1 = 0;
                c2 = lc;
            }
            else if (mode === 'column') {
                r1 = 0;
                r2 = lr;
                c1 = Math.max(0, Math.min(c1, lc));
                c2 = Math.max(0, Math.min(c2, lc));
            }
            else {
                r1 = Math.max(0, Math.min(r1, lr));
                r2 = Math.max(0, Math.min(r2, lr));
                c1 = Math.max(0, Math.min(c1, lc));
                c2 = Math.max(0, Math.min(c2, lc));
            }
            // Assign the modified selection to the array.
            this._selections[j++] = { r1: r1, c1: c1, r2: r2, c2: c2 };
        }
        // Remove the stale selections.
        this._selections.length = j;
        // Emit the changed signal.
        this.emitChanged();
    };
    return BasicSelectionModel;
}(selectionmodel_1.SelectionModel));
exports.BasicSelectionModel = BasicSelectionModel;
