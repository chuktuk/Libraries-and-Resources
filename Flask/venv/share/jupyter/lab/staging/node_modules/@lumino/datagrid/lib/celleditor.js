"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var keyboard_1 = require("@lumino/keyboard");
var signaling_1 = require("@lumino/signaling");
var notification_1 = require("./notification");
// default validation error message
var DEFAULT_INVALID_INPUT_MESSAGE = "Invalid input!";
/**
 * A cell input validator object which always returns valid.
 */
var PassInputValidator = /** @class */ (function () {
    function PassInputValidator() {
    }
    /**
     * Validate cell input.
     *
     * @param cell - The object holding cell configuration data.
     *
     * @param value - The cell value input.
     *
     * @returns An object with validation result.
     */
    PassInputValidator.prototype.validate = function (cell, value) {
        return { valid: true };
    };
    return PassInputValidator;
}());
exports.PassInputValidator = PassInputValidator;
/**
 * Text cell input validator.
 */
var TextInputValidator = /** @class */ (function () {
    function TextInputValidator() {
        /**
         * Minimum text length
         *
         * The default is Number.NaN, meaning no minimum constraint
         */
        this.minLength = Number.NaN;
        /**
         * Maximum text length
         *
         * The default is Number.NaN, meaning no maximum constraint
         */
        this.maxLength = Number.NaN;
        /**
         * Required text pattern as regular expression
         *
         * The default is null, meaning no pattern constraint
         */
        this.pattern = null;
    }
    /**
     * Validate cell input.
     *
     * @param cell - The object holding cell configuration data.
     *
     * @param value - The cell value input.
     *
     * @returns An object with validation result.
     */
    TextInputValidator.prototype.validate = function (cell, value) {
        if (value === null) {
            return { valid: true };
        }
        if (typeof value !== 'string') {
            return {
                valid: false,
                message: 'Input must be valid text'
            };
        }
        if (!isNaN(this.minLength) && value.length < this.minLength) {
            return {
                valid: false,
                message: "Text length must be greater than " + this.minLength
            };
        }
        if (!isNaN(this.maxLength) && value.length > this.maxLength) {
            return {
                valid: false,
                message: "Text length must be less than " + this.maxLength
            };
        }
        if (this.pattern && !this.pattern.test(value)) {
            return {
                valid: false,
                message: "Text doesn't match the required pattern"
            };
        }
        return { valid: true };
    };
    return TextInputValidator;
}());
exports.TextInputValidator = TextInputValidator;
/**
 * Integer cell input validator.
 */
var IntegerInputValidator = /** @class */ (function () {
    function IntegerInputValidator() {
        /**
         * Minimum value
         *
         * The default is Number.NaN, meaning no minimum constraint
         */
        this.min = Number.NaN;
        /**
         * Maximum value
         *
         * The default is Number.NaN, meaning no maximum constraint
         */
        this.max = Number.NaN;
    }
    /**
     * Validate cell input.
     *
     * @param cell - The object holding cell configuration data.
     *
     * @param value - The cell value input.
     *
     * @returns An object with validation result.
     */
    IntegerInputValidator.prototype.validate = function (cell, value) {
        if (value === null) {
            return { valid: true };
        }
        if (isNaN(value) || (value % 1 !== 0)) {
            return {
                valid: false,
                message: 'Input must be valid integer'
            };
        }
        if (!isNaN(this.min) && value < this.min) {
            return {
                valid: false,
                message: "Input must be greater than " + this.min
            };
        }
        if (!isNaN(this.max) && value > this.max) {
            return {
                valid: false,
                message: "Input must be less than " + this.max
            };
        }
        return { valid: true };
    };
    return IntegerInputValidator;
}());
exports.IntegerInputValidator = IntegerInputValidator;
/**
 * Real number cell input validator.
 */
var NumberInputValidator = /** @class */ (function () {
    function NumberInputValidator() {
        /**
         * Minimum value
         *
         * The default is Number.NaN, meaning no minimum constraint
         */
        this.min = Number.NaN;
        /**
         * Maximum value
         *
         * The default is Number.NaN, meaning no maximum constraint
         */
        this.max = Number.NaN;
    }
    /**
     * Validate cell input.
     *
     * @param cell - The object holding cell configuration data.
     *
     * @param value - The cell value input.
     *
     * @returns An object with validation result.
     */
    NumberInputValidator.prototype.validate = function (cell, value) {
        if (value === null) {
            return { valid: true };
        }
        if (isNaN(value)) {
            return {
                valid: false,
                message: 'Input must be valid number'
            };
        }
        if (!isNaN(this.min) && value < this.min) {
            return {
                valid: false,
                message: "Input must be greater than " + this.min
            };
        }
        if (!isNaN(this.max) && value > this.max) {
            return {
                valid: false,
                message: "Input must be less than " + this.max
            };
        }
        return { valid: true };
    };
    return NumberInputValidator;
}());
exports.NumberInputValidator = NumberInputValidator;
/**
 * An abstract base class that provides the most of the functionality
 * needed by a cell editor. All of the built-in cell editors
 * for various cell types are derived from this base class. Custom cell editors
 * can be easily implemented by extending this class.
 */
var CellEditor = /** @class */ (function () {
    /**
     * Construct a new cell editor.
     */
    function CellEditor() {
        var _this = this;
        /**
         * A signal emitted when input changes.
         */
        this.inputChanged = new signaling_1.Signal(this);
        /**
         * Notification popup used to show validation error messages.
         */
        this.validityNotification = null;
        /**
         * Whether the cell editor is disposed.
         */
        this._disposed = false;
        /**
         * Whether the value input is valid.
         */
        this._validInput = true;
        this.inputChanged.connect(function () {
            _this.validate();
        });
    }
    Object.defineProperty(CellEditor.prototype, "isDisposed", {
        /**
         * Whether the cell editor is disposed.
         */
        get: function () {
            return this._disposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by cell editor.
     */
    CellEditor.prototype.dispose = function () {
        if (this._disposed) {
            return;
        }
        this._closeValidityNotification();
        this._disposed = true;
        this.cell.grid.node.removeChild(this.viewportOccluder);
    };
    /**
     * Start editing the cell.
     *
     * @param cell - The object holding cell configuration data.
     *
     * @param options - The cell editing options.
     */
    CellEditor.prototype.edit = function (cell, options) {
        var _this = this;
        this.cell = cell;
        this.onCommit = options && options.onCommit;
        this.onCancel = options && options.onCancel;
        this.validator = (options && options.validator) ? options.validator : this.createValidatorBasedOnType();
        cell.grid.node.addEventListener('wheel', function () {
            _this._closeValidityNotification();
            _this.updatePosition();
        });
        this._addContainer();
        this.updatePosition();
        this.startEditing();
    };
    /**
     * Cancel editing the cell.
     */
    CellEditor.prototype.cancel = function () {
        if (this._disposed) {
            return;
        }
        this.dispose();
        if (this.onCancel) {
            this.onCancel();
        }
    };
    Object.defineProperty(CellEditor.prototype, "validInput", {
        /**
         * Whether the value input is valid.
         */
        get: function () {
            return this._validInput;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Validate the cell input. Shows validation error notification when input is invalid.
     */
    CellEditor.prototype.validate = function () {
        var value;
        try {
            value = this.getInput();
        }
        catch (error) {
            console.log("Input error: " + error.message);
            this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);
            return;
        }
        if (this.validator) {
            var result = this.validator.validate(this.cell, value);
            if (result.valid) {
                this.setValidity(true);
            }
            else {
                this.setValidity(false, result.message || DEFAULT_INVALID_INPUT_MESSAGE);
            }
        }
        else {
            this.setValidity(true);
        }
    };
    /**
     * Set validity flag.
     *
     * @param valid - Whether the input is valid.
     *
     * @param message - Notification message to show.
     *
     * If message is set to empty string (which is the default)
     * existing notification popup is removed if any.
     */
    CellEditor.prototype.setValidity = function (valid, message) {
        if (message === void 0) { message = ""; }
        this._validInput = valid;
        this._closeValidityNotification();
        if (valid) {
            this.editorContainer.classList.remove('invalid');
        }
        else {
            this.editorContainer.classList.add('invalid');
            // show a notification popup
            if (message !== "") {
                this.validityNotification = new notification_1.Notification({
                    target: this.editorContainer,
                    message: message,
                    placement: 'bottom',
                    timeout: 5000
                });
                this.validityNotification.show();
            }
        }
    };
    /**
     * Create and return a cell input validator based on configuration of the
     * cell being edited. If no suitable validator can be found, it returns undefined.
     */
    CellEditor.prototype.createValidatorBasedOnType = function () {
        var cell = this.cell;
        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);
        switch (metadata && metadata.type) {
            case 'string':
                {
                    var validator = new TextInputValidator();
                    if (typeof (metadata.format) === 'string') {
                        var format = metadata.format;
                        switch (format) {
                            case 'email':
                                validator.pattern = new RegExp("^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$");
                                break;
                            case 'uuid':
                                validator.pattern = new RegExp("[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}");
                                break;
                            case 'uri':
                                // TODO
                                break;
                            case 'binary':
                                // TODO
                                break;
                        }
                    }
                    if (metadata.constraint) {
                        if (metadata.constraint.minLength !== undefined) {
                            validator.minLength = metadata.constraint.minLength;
                        }
                        if (metadata.constraint.maxLength !== undefined) {
                            validator.maxLength = metadata.constraint.maxLength;
                        }
                        if (typeof (metadata.constraint.pattern) === 'string') {
                            validator.pattern = new RegExp(metadata.constraint.pattern);
                        }
                    }
                    return validator;
                }
                break;
            case 'number':
                {
                    var validator = new NumberInputValidator();
                    if (metadata.constraint) {
                        if (metadata.constraint.minimum !== undefined) {
                            validator.min = metadata.constraint.minimum;
                        }
                        if (metadata.constraint.maximum !== undefined) {
                            validator.max = metadata.constraint.maximum;
                        }
                    }
                    return validator;
                }
                break;
            case 'integer':
                {
                    var validator = new IntegerInputValidator();
                    if (metadata.constraint) {
                        if (metadata.constraint.minimum !== undefined) {
                            validator.min = metadata.constraint.minimum;
                        }
                        if (metadata.constraint.maximum !== undefined) {
                            validator.max = metadata.constraint.maximum;
                        }
                    }
                    return validator;
                }
                break;
        }
        return undefined;
    };
    /**
     * Compute cell rectangle and return with other cell properties.
     */
    CellEditor.prototype.getCellInfo = function (cell) {
        var grid = cell.grid, row = cell.row, column = cell.column;
        var data = grid.dataModel.data('body', row, column);
        var columnX = grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);
        var rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);
        var width = grid.columnSize('body', column);
        var height = grid.rowSize('body', row);
        return {
            grid: grid,
            row: row,
            column: column,
            data: data,
            x: columnX,
            y: rowY,
            width: width,
            height: height
        };
    };
    /**
     * Reposition cell editor by moving viewport occluder and cell editor container.
     */
    CellEditor.prototype.updatePosition = function () {
        var grid = this.cell.grid;
        var cellInfo = this.getCellInfo(this.cell);
        var headerHeight = grid.headerHeight;
        var headerWidth = grid.headerWidth;
        this.viewportOccluder.style.top = headerHeight + 'px';
        this.viewportOccluder.style.left = headerWidth + 'px';
        this.viewportOccluder.style.width = (grid.viewportWidth - headerWidth) + 'px';
        this.viewportOccluder.style.height = (grid.viewportHeight - headerHeight) + 'px';
        this.editorContainer.style.left = (cellInfo.x - 1 - headerWidth) + 'px';
        this.editorContainer.style.top = (cellInfo.y - 1 - headerHeight) + 'px';
        this.editorContainer.style.width = (cellInfo.width + 1) + 'px';
        this.editorContainer.style.height = (cellInfo.height + 1) + 'px';
        this.editorContainer.style.visibility = 'visible';
    };
    /**
     * Commit the edited value.
     *
     * @param cursorMovement - Cursor move direction based on keys pressed to end the edit.
     *
     * @returns true on valid input, false otherwise.
     */
    CellEditor.prototype.commit = function (cursorMovement) {
        if (cursorMovement === void 0) { cursorMovement = 'none'; }
        this.validate();
        if (!this._validInput) {
            return false;
        }
        var value;
        try {
            value = this.getInput();
        }
        catch (error) {
            console.log("Input error: " + error.message);
            return false;
        }
        this.dispose();
        if (this.onCommit) {
            this.onCommit({
                cell: this.cell,
                value: value,
                cursorMovement: cursorMovement
            });
        }
        return true;
    };
    /**
     * Create container elements needed to prevent editor widget overflow
     * beyond viewport and to position cell editor widget.
     */
    CellEditor.prototype._addContainer = function () {
        var _this = this;
        this.viewportOccluder = document.createElement('div');
        this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';
        this.cell.grid.node.appendChild(this.viewportOccluder);
        this.editorContainer = document.createElement('div');
        this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';
        this.viewportOccluder.appendChild(this.editorContainer);
        // update mouse event pass-through state based on input validity
        this.editorContainer.addEventListener('mouseleave', function (event) {
            _this.viewportOccluder.style.pointerEvents = _this._validInput ? 'none' : 'auto';
        });
        this.editorContainer.addEventListener('mouseenter', function (event) {
            _this.viewportOccluder.style.pointerEvents = 'none';
        });
    };
    /**
     * Remove validity notification popup.
     */
    CellEditor.prototype._closeValidityNotification = function () {
        if (this.validityNotification) {
            this.validityNotification.close();
            this.validityNotification = null;
        }
    };
    return CellEditor;
}());
exports.CellEditor = CellEditor;
/**
 * Abstract base class with shared functionality
 * for cell editors which use HTML Input widget as editor.
 */
var InputCellEditor = /** @class */ (function (_super) {
    __extends(InputCellEditor, _super);
    function InputCellEditor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Handle the DOM events for the editor.
     *
     * @param event - The DOM event sent to the editor.
     */
    InputCellEditor.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._onKeyDown(event);
                break;
            case 'blur':
                this._onBlur(event);
                break;
            case 'input':
                this._onInput(event);
                break;
        }
    };
    /**
     * Dispose of the resources held by cell editor.
     */
    InputCellEditor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._unbindEvents();
        _super.prototype.dispose.call(this);
    };
    /**
     * Start editing the cell.
     */
    InputCellEditor.prototype.startEditing = function () {
        this.createWidget();
        var cell = this.cell;
        var cellInfo = this.getCellInfo(cell);
        this.input.value = this.deserialize(cellInfo.data);
        this.editorContainer.appendChild(this.input);
        this.input.focus();
        this.input.select();
        this.bindEvents();
    };
    InputCellEditor.prototype.deserialize = function (value) {
        if (value === null || value === undefined) {
            return '';
        }
        return value.toString();
    };
    InputCellEditor.prototype.createWidget = function () {
        var input = document.createElement('input');
        input.classList.add('lm-DataGrid-cellEditorWidget');
        input.classList.add('lm-DataGrid-cellEditorInput');
        input.spellcheck = false;
        input.type = this.inputType;
        this.input = input;
    };
    InputCellEditor.prototype.bindEvents = function () {
        this.input.addEventListener('keydown', this);
        this.input.addEventListener('blur', this);
        this.input.addEventListener('input', this);
    };
    InputCellEditor.prototype._unbindEvents = function () {
        this.input.removeEventListener('keydown', this);
        this.input.removeEventListener('blur', this);
        this.input.removeEventListener('input', this);
    };
    InputCellEditor.prototype._onKeyDown = function (event) {
        switch (keyboard_1.getKeyboardLayout().keyForKeydownEvent(event)) {
            case 'Enter':
                this.commit(event.shiftKey ? 'up' : 'down');
                break;
            case 'Tab':
                this.commit(event.shiftKey ? 'left' : 'right');
                event.stopPropagation();
                event.preventDefault();
                break;
            case 'Escape':
                this.cancel();
                break;
            default:
                break;
        }
    };
    InputCellEditor.prototype._onBlur = function (event) {
        if (this.isDisposed) {
            return;
        }
        if (!this.commit()) {
            event.preventDefault();
            event.stopPropagation();
            this.input.focus();
        }
    };
    InputCellEditor.prototype._onInput = function (event) {
        this.inputChanged.emit(void 0);
    };
    return InputCellEditor;
}(CellEditor));
exports.InputCellEditor = InputCellEditor;
/**
 * Cell editor for text cells.
 */
var TextCellEditor = /** @class */ (function (_super) {
    __extends(TextCellEditor, _super);
    function TextCellEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.inputType = 'text';
        return _this;
    }
    /**
     * Return the current text input entered.
     */
    TextCellEditor.prototype.getInput = function () {
        return this.input.value;
    };
    return TextCellEditor;
}(InputCellEditor));
exports.TextCellEditor = TextCellEditor;
/**
 * Cell editor for real number cells.
 */
var NumberCellEditor = /** @class */ (function (_super) {
    __extends(NumberCellEditor, _super);
    function NumberCellEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.inputType = 'number';
        return _this;
    }
    /**
     * Start editing the cell.
     */
    NumberCellEditor.prototype.startEditing = function () {
        _super.prototype.startEditing.call(this);
        this.input.step = 'any';
        var cell = this.cell;
        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);
        var constraint = metadata.constraint;
        if (constraint) {
            if (constraint.minimum) {
                this.input.min = constraint.minimum;
            }
            if (constraint.maximum) {
                this.input.max = constraint.maximum;
            }
        }
    };
    /**
     * Return the current number input entered. This method throws exception
     * if input is invalid.
     */
    NumberCellEditor.prototype.getInput = function () {
        var value = this.input.value;
        if (value.trim() === '') {
            return null;
        }
        var floatValue = parseFloat(value);
        if (isNaN(floatValue)) {
            throw new Error('Invalid input');
        }
        return floatValue;
    };
    return NumberCellEditor;
}(InputCellEditor));
exports.NumberCellEditor = NumberCellEditor;
/**
 * Cell editor for integer cells.
 */
var IntegerCellEditor = /** @class */ (function (_super) {
    __extends(IntegerCellEditor, _super);
    function IntegerCellEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.inputType = 'number';
        return _this;
    }
    /**
     * Start editing the cell.
     */
    IntegerCellEditor.prototype.startEditing = function () {
        _super.prototype.startEditing.call(this);
        this.input.step = '1';
        var cell = this.cell;
        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);
        var constraint = metadata.constraint;
        if (constraint) {
            if (constraint.minimum) {
                this.input.min = constraint.minimum;
            }
            if (constraint.maximum) {
                this.input.max = constraint.maximum;
            }
        }
    };
    /**
     * Return the current integer input entered. This method throws exception
     * if input is invalid.
     */
    IntegerCellEditor.prototype.getInput = function () {
        var value = this.input.value;
        if (value.trim() === '') {
            return null;
        }
        var intValue = parseInt(value);
        if (isNaN(intValue)) {
            throw new Error('Invalid input');
        }
        return intValue;
    };
    return IntegerCellEditor;
}(InputCellEditor));
exports.IntegerCellEditor = IntegerCellEditor;
/**
 * Cell editor for date cells.
 */
var DateCellEditor = /** @class */ (function (_super) {
    __extends(DateCellEditor, _super);
    function DateCellEditor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Handle the DOM events for the editor.
     *
     * @param event - The DOM event sent to the editor.
     */
    DateCellEditor.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._onKeyDown(event);
                break;
            case 'blur':
                this._onBlur(event);
                break;
        }
    };
    /**
     * Dispose of the resources held by cell editor.
     */
    DateCellEditor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._unbindEvents();
        _super.prototype.dispose.call(this);
    };
    /**
     * Start editing the cell.
     */
    DateCellEditor.prototype.startEditing = function () {
        this._createWidget();
        var cell = this.cell;
        var cellInfo = this.getCellInfo(cell);
        this._input.value = this._deserialize(cellInfo.data);
        this.editorContainer.appendChild(this._input);
        this._input.focus();
        this._bindEvents();
    };
    /**
     * Return the current date input entered.
     */
    DateCellEditor.prototype.getInput = function () {
        return this._input.value;
    };
    DateCellEditor.prototype._deserialize = function (value) {
        if (value === null || value === undefined) {
            return '';
        }
        return value.toString();
    };
    DateCellEditor.prototype._createWidget = function () {
        var input = document.createElement('input');
        input.type = 'date';
        input.pattern = "\d{4}-\d{2}-\d{2}";
        input.classList.add('lm-DataGrid-cellEditorWidget');
        input.classList.add('lm-DataGrid-cellEditorInput');
        this._input = input;
    };
    DateCellEditor.prototype._bindEvents = function () {
        this._input.addEventListener('keydown', this);
        this._input.addEventListener('blur', this);
    };
    DateCellEditor.prototype._unbindEvents = function () {
        this._input.removeEventListener('keydown', this);
        this._input.removeEventListener('blur', this);
    };
    DateCellEditor.prototype._onKeyDown = function (event) {
        switch (keyboard_1.getKeyboardLayout().keyForKeydownEvent(event)) {
            case 'Enter':
                this.commit(event.shiftKey ? 'up' : 'down');
                break;
            case 'Tab':
                this.commit(event.shiftKey ? 'left' : 'right');
                event.stopPropagation();
                event.preventDefault();
                break;
            case 'Escape':
                this.cancel();
                break;
            default:
                break;
        }
    };
    DateCellEditor.prototype._onBlur = function (event) {
        if (this.isDisposed) {
            return;
        }
        if (!this.commit()) {
            event.preventDefault();
            event.stopPropagation();
            this._input.focus();
        }
    };
    return DateCellEditor;
}(CellEditor));
exports.DateCellEditor = DateCellEditor;
/**
 * Cell editor for boolean cells.
 */
var BooleanCellEditor = /** @class */ (function (_super) {
    __extends(BooleanCellEditor, _super);
    function BooleanCellEditor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Handle the DOM events for the editor.
     *
     * @param event - The DOM event sent to the editor.
     */
    BooleanCellEditor.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._onKeyDown(event);
                break;
            case 'mousedown':
                // fix focus loss problem in Safari and Firefox
                this._input.focus();
                event.stopPropagation();
                event.preventDefault();
                break;
            case 'blur':
                this._onBlur(event);
                break;
        }
    };
    /**
     * Dispose of the resources held by cell editor.
     */
    BooleanCellEditor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._unbindEvents();
        _super.prototype.dispose.call(this);
    };
    /**
     * Start editing the cell.
     */
    BooleanCellEditor.prototype.startEditing = function () {
        this._createWidget();
        var cell = this.cell;
        var cellInfo = this.getCellInfo(cell);
        this._input.checked = this._deserialize(cellInfo.data);
        this.editorContainer.appendChild(this._input);
        this._input.focus();
        this._bindEvents();
    };
    /**
     * Return the current boolean input entered.
     */
    BooleanCellEditor.prototype.getInput = function () {
        return this._input.checked;
    };
    BooleanCellEditor.prototype._deserialize = function (value) {
        if (value === null || value === undefined) {
            return false;
        }
        return value == true;
    };
    BooleanCellEditor.prototype._createWidget = function () {
        var input = document.createElement('input');
        input.classList.add('lm-DataGrid-cellEditorWidget');
        input.classList.add('lm-DataGrid-cellEditorCheckbox');
        input.type = 'checkbox';
        input.spellcheck = false;
        this._input = input;
    };
    BooleanCellEditor.prototype._bindEvents = function () {
        this._input.addEventListener('keydown', this);
        this._input.addEventListener('mousedown', this);
        this._input.addEventListener('blur', this);
    };
    BooleanCellEditor.prototype._unbindEvents = function () {
        this._input.removeEventListener('keydown', this);
        this._input.removeEventListener('mousedown', this);
        this._input.removeEventListener('blur', this);
    };
    BooleanCellEditor.prototype._onKeyDown = function (event) {
        switch (keyboard_1.getKeyboardLayout().keyForKeydownEvent(event)) {
            case 'Enter':
                this.commit(event.shiftKey ? 'up' : 'down');
                break;
            case 'Tab':
                this.commit(event.shiftKey ? 'left' : 'right');
                event.stopPropagation();
                event.preventDefault();
                break;
            case 'Escape':
                this.cancel();
                break;
            default:
                break;
        }
    };
    BooleanCellEditor.prototype._onBlur = function (event) {
        if (this.isDisposed) {
            return;
        }
        if (!this.commit()) {
            event.preventDefault();
            event.stopPropagation();
            this._input.focus();
        }
    };
    return BooleanCellEditor;
}(CellEditor));
exports.BooleanCellEditor = BooleanCellEditor;
/**
 * Cell editor for option cells.
 *
 * It supports multiple option selection. If cell metadata contains
 * type attribute 'array', then it behaves as a multi select.
 * In that case cell data is expected to be list of string values.
 */
var OptionCellEditor = /** @class */ (function (_super) {
    __extends(OptionCellEditor, _super);
    function OptionCellEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._isMultiSelect = false;
        return _this;
    }
    /**
     * Dispose of the resources held by cell editor.
     */
    OptionCellEditor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        _super.prototype.dispose.call(this);
        if (this._isMultiSelect) {
            document.body.removeChild(this._select);
        }
    };
    /**
     * Start editing the cell.
     */
    OptionCellEditor.prototype.startEditing = function () {
        var cell = this.cell;
        var cellInfo = this.getCellInfo(cell);
        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);
        this._isMultiSelect = metadata.type === 'array';
        this._createWidget();
        if (this._isMultiSelect) {
            this._select.multiple = true;
            var values = this._deserialize(cellInfo.data);
            for (var i = 0; i < this._select.options.length; ++i) {
                var option = this._select.options.item(i);
                option.selected = values.indexOf(option.value) !== -1;
            }
            document.body.appendChild(this._select);
        }
        else {
            this._select.value = this._deserialize(cellInfo.data);
            this.editorContainer.appendChild(this._select);
        }
        this._select.focus();
        this._bindEvents();
        this.updatePosition();
    };
    /**
     * Return the current option input.
     */
    OptionCellEditor.prototype.getInput = function () {
        if (this._isMultiSelect) {
            var input = [];
            for (var i = 0; i < this._select.selectedOptions.length; ++i) {
                input.push(this._select.selectedOptions.item(i).value);
            }
            return input;
        }
        else {
            return this._select.value;
        }
    };
    /**
     * Reposition cell editor.
     */
    OptionCellEditor.prototype.updatePosition = function () {
        _super.prototype.updatePosition.call(this);
        if (!this._isMultiSelect) {
            return;
        }
        var cellInfo = this.getCellInfo(this.cell);
        this._select.style.position = 'absolute';
        var editorContainerRect = this.editorContainer.getBoundingClientRect();
        this._select.style.left = editorContainerRect.left + 'px';
        this._select.style.top = (editorContainerRect.top + cellInfo.height) + 'px';
        this._select.style.width = editorContainerRect.width + 'px';
        this._select.style.maxHeight = '60px';
        this.editorContainer.style.visibility = 'hidden';
    };
    OptionCellEditor.prototype._deserialize = function (value) {
        if (value === null || value === undefined) {
            return '';
        }
        if (this._isMultiSelect) {
            var values = [];
            if (Array.isArray(value)) {
                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                    var item = value_1[_i];
                    values.push(item.toString());
                }
            }
            return values;
        }
        else {
            return value.toString();
        }
    };
    OptionCellEditor.prototype._createWidget = function () {
        var cell = this.cell;
        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);
        var items = metadata.constraint.enum;
        var select = document.createElement('select');
        select.classList.add('lm-DataGrid-cellEditorWidget');
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            var option = document.createElement("option");
            option.value = item;
            option.text = item;
            select.appendChild(option);
        }
        this._select = select;
    };
    OptionCellEditor.prototype._bindEvents = function () {
        this._select.addEventListener('keydown', this._onKeyDown.bind(this));
        this._select.addEventListener('blur', this._onBlur.bind(this));
    };
    OptionCellEditor.prototype._onKeyDown = function (event) {
        switch (keyboard_1.getKeyboardLayout().keyForKeydownEvent(event)) {
            case 'Enter':
                this.commit(event.shiftKey ? 'up' : 'down');
                break;
            case 'Tab':
                this.commit(event.shiftKey ? 'left' : 'right');
                event.stopPropagation();
                event.preventDefault();
                break;
            case 'Escape':
                this.cancel();
                break;
            default:
                break;
        }
    };
    OptionCellEditor.prototype._onBlur = function (event) {
        if (this.isDisposed) {
            return;
        }
        if (!this.commit()) {
            event.preventDefault();
            event.stopPropagation();
            this._select.focus();
        }
    };
    return OptionCellEditor;
}(CellEditor));
exports.OptionCellEditor = OptionCellEditor;
/**
 * Cell editor for option cells whose value can be any value
 * from set of pre-defined options or values that can be input by user.
 */
var DynamicOptionCellEditor = /** @class */ (function (_super) {
    __extends(DynamicOptionCellEditor, _super);
    function DynamicOptionCellEditor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Handle the DOM events for the editor.
     *
     * @param event - The DOM event sent to the editor.
     */
    DynamicOptionCellEditor.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._onKeyDown(event);
                break;
            case 'blur':
                this._onBlur(event);
                break;
        }
    };
    /**
     * Dispose of the resources held by cell editor.
     */
    DynamicOptionCellEditor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._unbindEvents();
        _super.prototype.dispose.call(this);
    };
    /**
     * Start editing the cell.
     */
    DynamicOptionCellEditor.prototype.startEditing = function () {
        this._createWidget();
        var cell = this.cell;
        var cellInfo = this.getCellInfo(cell);
        this._input.value = this._deserialize(cellInfo.data);
        this.editorContainer.appendChild(this._input);
        this._input.focus();
        this._input.select();
        this._bindEvents();
    };
    /**
     * Return the current option input.
     */
    DynamicOptionCellEditor.prototype.getInput = function () {
        return this._input.value;
    };
    DynamicOptionCellEditor.prototype._deserialize = function (value) {
        if (value === null || value === undefined) {
            return '';
        }
        return value.toString();
    };
    DynamicOptionCellEditor.prototype._createWidget = function () {
        var cell = this.cell;
        var grid = cell.grid;
        var dataModel = grid.dataModel;
        var rowCount = dataModel.rowCount('body');
        var listId = 'cell-editor-list';
        var list = document.createElement('datalist');
        list.id = listId;
        var input = document.createElement('input');
        input.classList.add('lm-DataGrid-cellEditorWidget');
        input.classList.add('lm-DataGrid-cellEditorInput');
        var valueSet = new Set();
        for (var r = 0; r < rowCount; ++r) {
            var data = dataModel.data('body', r, cell.column);
            if (data) {
                valueSet.add(data);
            }
        }
        valueSet.forEach(function (value) {
            var option = document.createElement("option");
            option.value = value;
            option.text = value;
            list.appendChild(option);
        });
        this.editorContainer.appendChild(list);
        input.setAttribute('list', listId);
        this._input = input;
    };
    DynamicOptionCellEditor.prototype._bindEvents = function () {
        this._input.addEventListener('keydown', this);
        this._input.addEventListener('blur', this);
    };
    DynamicOptionCellEditor.prototype._unbindEvents = function () {
        this._input.removeEventListener('keydown', this);
        this._input.removeEventListener('blur', this);
    };
    DynamicOptionCellEditor.prototype._onKeyDown = function (event) {
        switch (keyboard_1.getKeyboardLayout().keyForKeydownEvent(event)) {
            case 'Enter':
                this.commit(event.shiftKey ? 'up' : 'down');
                break;
            case 'Tab':
                this.commit(event.shiftKey ? 'left' : 'right');
                event.stopPropagation();
                event.preventDefault();
                break;
            case 'Escape':
                this.cancel();
                break;
            default:
                break;
        }
    };
    DynamicOptionCellEditor.prototype._onBlur = function (event) {
        if (this.isDisposed) {
            return;
        }
        if (!this.commit()) {
            event.preventDefault();
            event.stopPropagation();
            this._input.focus();
        }
    };
    return DynamicOptionCellEditor;
}(CellEditor));
exports.DynamicOptionCellEditor = DynamicOptionCellEditor;
