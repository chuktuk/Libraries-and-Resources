"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var domutils_1 = require("@lumino/domutils");
var dragdrop_1 = require("@lumino/dragdrop");
/**
 * A basic implementation of a data grid mouse handler.
 *
 * #### Notes
 * This class may be subclassed and customized as needed.
 */
var BasicMouseHandler = /** @class */ (function () {
    function BasicMouseHandler() {
        this._disposed = false;
    }
    /**
     * Dispose of the resources held by the mouse handler.
     */
    BasicMouseHandler.prototype.dispose = function () {
        // Bail early if the handler is already disposed.
        if (this._disposed) {
            return;
        }
        // Release any held resources.
        this.release();
        // Mark the handler as disposed.
        this._disposed = true;
    };
    Object.defineProperty(BasicMouseHandler.prototype, "isDisposed", {
        /**
         * Whether the mouse handler is disposed.
         */
        get: function () {
            return this._disposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Release the resources held by the handler.
     */
    BasicMouseHandler.prototype.release = function () {
        // Bail early if the is no press data.
        if (!this._pressData) {
            return;
        }
        // Clear the autoselect timeout.
        if (this._pressData.type === 'select') {
            this._pressData.timeout = -1;
        }
        // Clear the press data.
        this._pressData.override.dispose();
        this._pressData = null;
    };
    /**
     * Handle the mouse hover event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The mouse hover event of interest.
     */
    BasicMouseHandler.prototype.onMouseHover = function (grid, event) {
        // Hit test the grid.
        var hit = grid.hitTest(event.clientX, event.clientY);
        // Get the resize handle for the hit test.
        var handle = Private.resizeHandleForHitTest(hit);
        // Fetch the cursor for the handle.
        var cursor = Private.cursorForHandle(handle);
        // Update the viewport cursor based on the part.
        grid.viewport.node.style.cursor = cursor;
        // TODO support user-defined hover items
    };
    /**
     * Handle the mouse leave event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The mouse hover event of interest.
     */
    BasicMouseHandler.prototype.onMouseLeave = function (grid, event) {
        // TODO support user-defined hover popups.
        // Clear the viewport cursor.
        grid.viewport.node.style.cursor = '';
    };
    /**
     * Handle the mouse down event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The mouse down event of interest.
     */
    BasicMouseHandler.prototype.onMouseDown = function (grid, event) {
        // Unpack the event.
        var clientX = event.clientX, clientY = event.clientY;
        // Hit test the grid.
        var hit = grid.hitTest(clientX, clientY);
        // Unpack the hit test.
        var region = hit.region, row = hit.row, column = hit.column;
        // Bail if the hit test is on an uninteresting region.
        if (region === 'void') {
            return;
        }
        // Fetch the modifier flags.
        var shift = event.shiftKey;
        var accel = domutils_1.Platform.accelKey(event);
        // If the hit test is the body region, the only option is select.
        if (region === 'body') {
            // Fetch the selection model.
            var model_1 = grid.selectionModel;
            // Bail early if there is no selection model.
            if (!model_1) {
                return;
            }
            // Override the document cursor.
            var override_1 = dragdrop_1.Drag.overrideCursor('default');
            // Set up the press data.
            this._pressData = {
                type: 'select', region: region, row: row, column: column, override: override_1,
                localX: -1, localY: -1, timeout: -1
            };
            // Set up the selection variables.
            var r1_1;
            var c1_1;
            var r2_1;
            var c2_1;
            var cursorRow_1;
            var cursorColumn_1;
            var clear_1;
            // Accel == new selection, keep old selections.
            if (accel) {
                r1_1 = row;
                r2_1 = row;
                c1_1 = column;
                c2_1 = column;
                cursorRow_1 = row;
                cursorColumn_1 = column;
                clear_1 = 'none';
            }
            else if (shift) {
                r1_1 = model_1.cursorRow;
                r2_1 = row;
                c1_1 = model_1.cursorColumn;
                c2_1 = column;
                cursorRow_1 = model_1.cursorRow;
                cursorColumn_1 = model_1.cursorColumn;
                clear_1 = 'current';
            }
            else {
                r1_1 = row;
                r2_1 = row;
                c1_1 = column;
                c2_1 = column;
                cursorRow_1 = row;
                cursorColumn_1 = column;
                clear_1 = 'all';
            }
            // Make the selection.
            model_1.select({ r1: r1_1, c1: c1_1, r2: r2_1, c2: c2_1, cursorRow: cursorRow_1, cursorColumn: cursorColumn_1, clear: clear_1 });
            // Done.
            return;
        }
        // Otherwise, the hit test is on a header region.
        // Convert the hit test into a part.
        var handle = Private.resizeHandleForHitTest(hit);
        // Fetch the cursor for the handle.
        var cursor = Private.cursorForHandle(handle);
        // Handle horizontal resize.
        if (handle === 'left' || handle === 'right') {
            // Set up the resize data type.
            var type = 'column-resize';
            // Determine the column region.
            var rgn = (region === 'column-header' ? 'body' : 'row-header');
            // Determine the section index.
            var index = handle === 'left' ? column - 1 : column;
            // Fetch the section size.
            var size = grid.columnSize(rgn, index);
            // Override the document cursor.
            var override_2 = dragdrop_1.Drag.overrideCursor(cursor);
            // Create the temporary press data.
            this._pressData = { type: type, region: rgn, index: index, size: size, clientX: clientX, override: override_2 };
            // Done.
            return;
        }
        // Handle vertical resize
        if (handle === 'top' || handle === 'bottom') {
            // Set up the resize data type.
            var type = 'row-resize';
            // Determine the row region.
            var rgn = (region === 'row-header' ? 'body' : 'column-header');
            // Determine the section index.
            var index = handle === 'top' ? row - 1 : row;
            // Fetch the section size.
            var size = grid.rowSize(rgn, index);
            // Override the document cursor.
            var override_3 = dragdrop_1.Drag.overrideCursor(cursor);
            // Create the temporary press data.
            this._pressData = { type: type, region: rgn, index: index, size: size, clientY: clientY, override: override_3 };
            // Done.
            return;
        }
        // Otherwise, the only option is select.
        // Fetch the selection model.
        var model = grid.selectionModel;
        // Bail if there is no selection model.
        if (!model) {
            return;
        }
        // Override the document cursor.
        var override = dragdrop_1.Drag.overrideCursor('default');
        // Set up the press data.
        this._pressData = {
            type: 'select', region: region, row: row, column: column, override: override,
            localX: -1, localY: -1, timeout: -1
        };
        // Set up the selection variables.
        var r1;
        var c1;
        var r2;
        var c2;
        var cursorRow;
        var cursorColumn;
        var clear;
        // Compute the selection based on the pressed region.
        if (region === 'corner-header') {
            r1 = 0;
            r2 = Infinity;
            c1 = 0;
            c2 = Infinity;
            cursorRow = accel ? 0 : shift ? model.cursorRow : 0;
            cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;
            clear = accel ? 'none' : shift ? 'current' : 'all';
        }
        else if (region === 'row-header') {
            r1 = accel ? row : shift ? model.cursorRow : row;
            r2 = row;
            c1 = 0;
            c2 = Infinity;
            cursorRow = accel ? row : shift ? model.cursorRow : row;
            cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;
            clear = accel ? 'none' : shift ? 'current' : 'all';
        }
        else if (region === 'column-header') {
            r1 = 0;
            r2 = Infinity;
            c1 = accel ? column : shift ? model.cursorColumn : column;
            c2 = column;
            cursorRow = accel ? 0 : shift ? model.cursorRow : 0;
            cursorColumn = accel ? column : shift ? model.cursorColumn : column;
            clear = accel ? 'none' : shift ? 'current' : 'all';
        }
        else {
            r1 = accel ? row : shift ? model.cursorRow : row;
            r2 = row;
            c1 = accel ? column : shift ? model.cursorColumn : column;
            c2 = column;
            cursorRow = accel ? row : shift ? model.cursorRow : row;
            cursorColumn = accel ? column : shift ? model.cursorColumn : column;
            clear = accel ? 'none' : shift ? 'current' : 'all';
        }
        // Make the selection.
        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cursorRow, cursorColumn: cursorColumn, clear: clear });
    };
    /**
     * Handle the mouse move event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The mouse move event of interest.
     */
    BasicMouseHandler.prototype.onMouseMove = function (grid, event) {
        // Fetch the press data.
        var data = this._pressData;
        // Bail early if there is no press data.
        if (!data) {
            return;
        }
        // Handle a row resize.
        if (data.type === 'row-resize') {
            var dy = event.clientY - data.clientY;
            grid.resizeRow(data.region, data.index, data.size + dy);
            return;
        }
        // Handle a column resize.
        if (data.type === 'column-resize') {
            var dx = event.clientX - data.clientX;
            grid.resizeColumn(data.region, data.index, data.size + dx);
            return;
        }
        // Otherwise, it's a select.
        // Mouse moves during a corner header press are a no-op.
        if (data.region === 'corner-header') {
            return;
        }
        // Fetch the selection model.
        var model = grid.selectionModel;
        // Bail early if the selection model was removed.
        if (!model) {
            return;
        }
        // Map to local coordinates.
        var _a = grid.mapToLocal(event.clientX, event.clientY), lx = _a.lx, ly = _a.ly;
        // Update the local mouse coordinates in the press data.
        data.localX = lx;
        data.localY = ly;
        // Fetch the grid geometry.
        var hw = grid.headerWidth;
        var hh = grid.headerHeight;
        var vpw = grid.viewportWidth;
        var vph = grid.viewportHeight;
        var sx = grid.scrollX;
        var sy = grid.scrollY;
        var msx = grid.maxScrollY;
        var msy = grid.maxScrollY;
        // Fetch the selection mode.
        var mode = model.selectionMode;
        // Set up the timeout variable.
        var timeout = -1;
        // Compute the timemout based on hit region and mouse position.
        if (data.region === 'row-header' || mode === 'row') {
            if (ly < hh && sy > 0) {
                timeout = Private.computeTimeout(hh - ly);
            }
            else if (ly >= vph && sy < msy) {
                timeout = Private.computeTimeout(ly - vph);
            }
        }
        else if (data.region === 'column-header' || mode === 'column') {
            if (lx < hw && sx > 0) {
                timeout = Private.computeTimeout(hw - lx);
            }
            else if (lx >= vpw && sx < msx) {
                timeout = Private.computeTimeout(lx - vpw);
            }
        }
        else {
            if (lx < hw && sx > 0) {
                timeout = Private.computeTimeout(hw - lx);
            }
            else if (lx >= vpw && sx < msx) {
                timeout = Private.computeTimeout(lx - vpw);
            }
            else if (ly < hh && sy > 0) {
                timeout = Private.computeTimeout(hh - ly);
            }
            else if (ly >= vph && sy < msy) {
                timeout = Private.computeTimeout(ly - vph);
            }
        }
        // Update or initiate the autoselect if needed.
        if (timeout >= 0) {
            if (data.timeout < 0) {
                data.timeout = timeout;
                setTimeout(function () { Private.autoselect(grid, data); }, timeout);
            }
            else {
                data.timeout = timeout;
            }
            return;
        }
        // Otherwise, clear the autoselect timeout.
        data.timeout = -1;
        // Map the position to virtual coordinates.
        var _b = grid.mapToVirtual(event.clientX, event.clientY), vx = _b.vx, vy = _b.vy;
        // Clamp the coordinates to the limits.
        vx = Math.max(0, Math.min(vx, grid.bodyWidth - 1));
        vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));
        // Set up the selection variables.
        var r1;
        var c1;
        var r2;
        var c2;
        var cursorRow = model.cursorRow;
        var cursorColumn = model.cursorColumn;
        var clear = 'current';
        // Compute the selection based pressed region.
        if (data.region === 'row-header' || mode === 'row') {
            r1 = data.row;
            r2 = grid.rowAt('body', vy);
            c1 = 0;
            c2 = Infinity;
        }
        else if (data.region === 'column-header' || mode === 'column') {
            r1 = 0;
            r2 = Infinity;
            c1 = data.column;
            c2 = grid.columnAt('body', vx);
        }
        else {
            r1 = cursorRow;
            r2 = grid.rowAt('body', vy);
            c1 = cursorColumn;
            c2 = grid.columnAt('body', vx);
        }
        // Make the selection.
        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cursorRow, cursorColumn: cursorColumn, clear: clear });
    };
    /**
     * Handle the mouse up event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The mouse up event of interest.
     */
    BasicMouseHandler.prototype.onMouseUp = function (grid, event) {
        this.release();
    };
    /**
     * Handle the mouse double click event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The mouse up event of interest.
     */
    BasicMouseHandler.prototype.onMouseDoubleClick = function (grid, event) {
        if (!grid.dataModel) {
            this.release();
            return;
        }
        // Unpack the event.
        var clientX = event.clientX, clientY = event.clientY;
        // Hit test the grid.
        var hit = grid.hitTest(clientX, clientY);
        // Unpack the hit test.
        var region = hit.region, row = hit.row, column = hit.column;
        if (region === 'void') {
            this.release();
            return;
        }
        if (region === 'body') {
            if (grid.editable) {
                var cell = {
                    grid: grid,
                    row: row,
                    column: column
                };
                grid.editorController.edit(cell);
            }
        }
        this.release();
    };
    /**
     * Handle the context menu event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The context menu event of interest.
     */
    BasicMouseHandler.prototype.onContextMenu = function (grid, event) {
        // TODO support user-defined context menus
    };
    /**
     * Handle the wheel event for the data grid.
     *
     * @param grid - The data grid of interest.
     *
     * @param event - The wheel event of interest.
     */
    BasicMouseHandler.prototype.onWheel = function (grid, event) {
        // Bail if a mouse press is in progress.
        if (this._pressData) {
            return;
        }
        // Extract the delta X and Y movement.
        var dx = event.deltaX;
        var dy = event.deltaY;
        // Convert the delta values to pixel values.
        switch (event.deltaMode) {
            case 0: // DOM_DELTA_PIXEL
                break;
            case 1: // DOM_DELTA_LINE
                var ds = grid.defaultSizes;
                dx *= ds.columnWidth;
                dy *= ds.rowHeight;
                break;
            case 2: // DOM_DELTA_PAGE
                dx *= grid.pageWidth;
                dy *= grid.pageHeight;
                break;
            default:
                throw 'unreachable';
        }
        // Scroll by the desired amount.
        grid.scrollBy(dx, dy);
    };
    return BasicMouseHandler;
}());
exports.BasicMouseHandler = BasicMouseHandler;
/**
 * The namespace for the module implementation details.
 */
var Private;
(function (Private) {
    /**
     * Get the resize handle for a grid hit test.
     */
    function resizeHandleForHitTest(hit) {
        // Fetch the row and column.
        var r = hit.row;
        var c = hit.column;
        // Fetch the leading and trailing sizes.
        var lw = hit.x;
        var lh = hit.y;
        var tw = hit.width - hit.x;
        var th = hit.height - hit.y;
        // Set up the result variable.
        var result;
        // Dispatch based on hit test region.
        switch (hit.region) {
            case 'corner-header':
                if (c > 0 && lw <= 5) {
                    result = 'left';
                }
                else if (tw <= 6) {
                    result = 'right';
                }
                else if (r > 0 && lh <= 5) {
                    result = 'top';
                }
                else if (th <= 6) {
                    result = 'bottom';
                }
                else {
                    result = 'none';
                }
                break;
            case 'column-header':
                if (c > 0 && lw <= 5) {
                    result = 'left';
                }
                else if (tw <= 6) {
                    result = 'right';
                }
                else if (r > 0 && lh <= 5) {
                    result = 'top';
                }
                else if (th <= 6) {
                    result = 'bottom';
                }
                else {
                    result = 'none';
                }
                break;
            case 'row-header':
                if (c > 0 && lw <= 5) {
                    result = 'left';
                }
                else if (tw <= 6) {
                    result = 'right';
                }
                else if (r > 0 && lh <= 5) {
                    result = 'top';
                }
                else if (th <= 6) {
                    result = 'bottom';
                }
                else {
                    result = 'none';
                }
                break;
            case 'body':
                result = 'none';
                break;
            case 'void':
                result = 'none';
                break;
            default:
                throw 'unreachable';
        }
        // Return the result.
        return result;
    }
    Private.resizeHandleForHitTest = resizeHandleForHitTest;
    /**
     * Convert a resize handle into a cursor.
     */
    function cursorForHandle(handle) {
        return cursorMap[handle];
    }
    Private.cursorForHandle = cursorForHandle;
    /**
     * A timer callback for the autoselect loop.
     *
     * @param grid - The datagrid of interest.
     *
     * @param data - The select data of interest.
     */
    function autoselect(grid, data) {
        // Bail early if the timeout has been reset.
        if (data.timeout < 0) {
            return;
        }
        // Fetch the selection model.
        var model = grid.selectionModel;
        // Bail early if the selection model has been removed.
        if (!model) {
            return;
        }
        // Fetch the current selection.
        var cs = model.currentSelection();
        // Bail early if there is no current selection.
        if (!cs) {
            return;
        }
        // Fetch local X and Y coordinates of the mouse.
        var lx = data.localX;
        var ly = data.localY;
        // Set up the selection variables.
        var r1 = cs.r1;
        var c1 = cs.c1;
        var r2 = cs.r2;
        var c2 = cs.c2;
        var cursorRow = model.cursorRow;
        var cursorColumn = model.cursorColumn;
        var clear = 'current';
        // Fetch the grid geometry.
        var hw = grid.headerWidth;
        var hh = grid.headerHeight;
        var vpw = grid.viewportWidth;
        var vph = grid.viewportHeight;
        // Fetch the selection mode.
        var mode = model.selectionMode;
        // Update the selection based on the hit region.
        if (data.region === 'row-header' || mode === 'row') {
            r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;
        }
        else if (data.region === 'column-header' || mode === 'column') {
            c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;
        }
        else {
            r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;
            c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;
        }
        // Update the current selection.
        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cursorRow, cursorColumn: cursorColumn, clear: clear });
        // Re-fetch the current selection.
        cs = model.currentSelection();
        // Bail if there is no selection.
        if (!cs) {
            return;
        }
        // Scroll the grid based on the hit region.
        if (data.region === 'row-header' || mode === 'row') {
            grid.scrollToRow(cs.r2);
        }
        else if (data.region === 'column-header' || mode == 'column') {
            grid.scrollToColumn(cs.c2);
        }
        else if (mode === 'cell') {
            grid.scrollToCell(cs.r2, cs.c2);
        }
        // Schedule the next call with the current timeout.
        setTimeout(function () { autoselect(grid, data); }, data.timeout);
    }
    Private.autoselect = autoselect;
    /**
     * Compute the scroll timeout for the given delta distance.
     *
     * @param delta - The delta pixels from the origin.
     *
     * @returns The scaled timeout in milliseconds.
     */
    function computeTimeout(delta) {
        return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);
    }
    Private.computeTimeout = computeTimeout;
    /**
     * A mapping of resize handle to cursor.
     */
    var cursorMap = {
        top: 'ns-resize',
        left: 'ew-resize',
        right: 'ew-resize',
        bottom: 'ns-resize',
        none: 'default'
    };
})(Private || (Private = {}));
