"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2019, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var celleditor_1 = require("./celleditor");
/**
 * Resolve a config option for a cell editor.
 *
 * @param option - The config option to resolve.
 *
 * @param config - The cell config object.
 *
 * @returns The resolved value for the option.
 */
function resolveOption(option, config) {
    return typeof option === 'function' ? option(config) : option;
}
exports.resolveOption = resolveOption;
/**
 * An object which manages cell editing. It stores editor overrides,
 * decides which editor to use for a cell, makes sure there is only one editor active.
 */
var CellEditorController = /** @class */ (function () {
    function CellEditorController() {
        // active cell editor
        this._editor = null;
        // active cell being edited
        this._cell = null;
        // cell editor overrides based on cell data type identifier
        this._typeBasedOverrides = new Map();
        // cell editor overrides based on partial metadata match
        this._metadataBasedOverrides = new Map();
    }
    /**
     * Override cell editor for the cells matching the identifier.
     *
     * @param identifier - Cell identifier to use when matching cells.
     * if identifier is a CellDataType, then cell matching is done using data type of the cell,
     * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,
     * if identifier is 'default' then override is used as default editor when no other editor is found suitable
     *
     * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.
     */
    CellEditorController.prototype.setEditor = function (identifier, editor) {
        if (typeof identifier === 'string') {
            this._typeBasedOverrides.set(identifier, editor);
        }
        else {
            var key = this._metadataIdentifierToKey(identifier);
            this._metadataBasedOverrides.set(key, [identifier, editor]);
        }
    };
    /**
     * Start editing a cell.
     *
     * @param cell - The object holding cell configuration data.
     *
     * @param options - The cell editing options.
     */
    CellEditorController.prototype.edit = function (cell, options) {
        var grid = cell.grid;
        if (!grid.editable) {
            console.error('Grid cannot be edited!');
            return false;
        }
        this.cancel();
        this._cell = cell;
        options = options || {};
        options.onCommit = options.onCommit || this._onCommit.bind(this);
        options.onCancel = options.onCancel || this._onCancel.bind(this);
        // if an editor is passed in with options, then use it for editing
        if (options.editor) {
            this._editor = options.editor;
            options.editor.edit(cell, options);
            return true;
        }
        // choose an editor based on overrides / cell data type
        var editor = this._getEditor(cell);
        if (editor) {
            this._editor = editor;
            editor.edit(cell, options);
            return true;
        }
        return false;
    };
    /**
     * Cancel editing.
     */
    CellEditorController.prototype.cancel = function () {
        if (this._editor) {
            this._editor.cancel();
            this._editor = null;
        }
        this._cell = null;
    };
    CellEditorController.prototype._onCommit = function (response) {
        var cell = this._cell;
        if (!cell) {
            return;
        }
        var grid = cell.grid;
        var dataModel = grid.dataModel;
        dataModel.setData('body', cell.row, cell.column, response.value);
        grid.viewport.node.focus();
        if (response.cursorMovement !== 'none') {
            grid.moveCursor(response.cursorMovement);
            grid.scrollToCursor();
        }
    };
    CellEditorController.prototype._onCancel = function () {
        if (!this._cell) {
            return;
        }
        this._cell.grid.viewport.node.focus();
    };
    CellEditorController.prototype._getDataTypeKey = function (cell) {
        var metadata = cell.grid.dataModel ? cell.grid.dataModel.metadata('body', cell.row, cell.column) : null;
        if (!metadata) {
            return 'default';
        }
        var key = '';
        if (metadata) {
            key = metadata.type;
        }
        if (metadata.constraint && metadata.constraint.enum) {
            if (metadata.constraint.enum === 'dynamic') {
                key += ':dynamic-option';
            }
            else {
                key += ':option';
            }
        }
        return key;
    };
    CellEditorController.prototype._objectToKey = function (object) {
        var str = '';
        for (var key in object) {
            var value = object[key];
            if (typeof value === 'object') {
                str += key + ":" + this._objectToKey(value);
            }
            else {
                str += "[" + key + ":" + value + "]";
            }
        }
        return str;
    };
    CellEditorController.prototype._metadataIdentifierToKey = function (metadata) {
        return this._objectToKey(metadata);
    };
    CellEditorController.prototype._metadataMatchesIdentifier = function (metadata, identifier) {
        for (var key in identifier) {
            if (!metadata.hasOwnProperty(key)) {
                return false;
            }
            var identifierValue = identifier[key];
            var metadataValue = metadata[key];
            if (typeof identifierValue === 'object') {
                if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {
                    return false;
                }
            }
            else if (metadataValue !== identifierValue) {
                return false;
            }
        }
        return true;
    };
    CellEditorController.prototype._getMetadataBasedEditor = function (cell) {
        var _this = this;
        var editorMatched;
        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);
        if (metadata) {
            this._metadataBasedOverrides.forEach(function (value) {
                if (!editorMatched) {
                    var identifier = value[0], editor = value[1];
                    if (_this._metadataMatchesIdentifier(metadata, identifier)) {
                        editorMatched = resolveOption(editor, cell);
                    }
                }
            });
        }
        return editorMatched;
    };
    /**
     * Choose the most appropriate cell editor to use based on overrides / cell data type.
     *
     * If no match is found in overrides or based on cell data type, and if cell has a primitive
     * data type then TextCellEditor is used as default cell editor. If 'default' cell editor
     * is overridden, then it is used instead of TextCellEditor for default.
     */
    CellEditorController.prototype._getEditor = function (cell) {
        var dtKey = this._getDataTypeKey(cell);
        // find an editor based on data type based override
        if (this._typeBasedOverrides.has(dtKey)) {
            var editor = this._typeBasedOverrides.get(dtKey);
            return resolveOption(editor, cell);
        } // find an editor based on metadata match based override
        else if (this._metadataBasedOverrides.size > 0) {
            var editor = this._getMetadataBasedEditor(cell);
            if (editor) {
                return editor;
            }
        }
        // choose an editor based on data type
        switch (dtKey) {
            case 'string':
                return new celleditor_1.TextCellEditor();
            case 'number':
                return new celleditor_1.NumberCellEditor();
            case 'integer':
                return new celleditor_1.IntegerCellEditor();
            case 'boolean':
                return new celleditor_1.BooleanCellEditor();
            case 'date':
                return new celleditor_1.DateCellEditor();
            case 'string:option':
            case 'number:option':
            case 'integer:option':
            case 'date:option':
            case 'array:option':
                return new celleditor_1.OptionCellEditor();
            case 'string:dynamic-option':
            case 'number:dynamic-option':
            case 'integer:dynamic-option':
            case 'date:dynamic-option':
                return new celleditor_1.DynamicOptionCellEditor();
        }
        // if an override exists for 'default', then use it
        if (this._typeBasedOverrides.has('default')) {
            var editor = this._typeBasedOverrides.get('default');
            return resolveOption(editor, cell);
        }
        // if cell has a primitive data type then use TextCellEditor
        var data = cell.grid.dataModel.data('body', cell.row, cell.column);
        if (!data || typeof data !== 'object') {
            return new celleditor_1.TextCellEditor();
        }
        // no suitable editor found for the cell
        return undefined;
    };
    return CellEditorController;
}());
exports.CellEditorController = CellEditorController;
