/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { JSONExt } from '@lumino/coreutils';
import { Signal } from '@lumino/signaling';
import { AttachmentsModel } from '@jupyterlab/attachments';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { UUID } from '@lumino/coreutils';
import { OutputAreaModel } from '@jupyterlab/outputarea';
export function isCodeCellModel(model) {
    return model.type === 'code';
}
export function isMarkdownCellModel(model) {
    return model.type === 'markdown';
}
export function isRawCellModel(model) {
    return model.type === 'raw';
}
/**
 * An implementation of the cell model.
 */
export class CellModel extends CodeEditor.Model {
    /**
     * Construct a cell model from optional cell content.
     */
    constructor(options) {
        super({ modelDB: options.modelDB });
        /**
         * A signal emitted when the state of the model changes.
         */
        this.contentChanged = new Signal(this);
        /**
         * A signal emitted when a model state changes.
         */
        this.stateChanged = new Signal(this);
        this.id = options.id || UUID.uuid4();
        this.value.changed.connect(this.onGenericChange, this);
        const cellType = this.modelDB.createValue('type');
        cellType.set(this.type);
        const observableMetadata = this.modelDB.createMap('metadata');
        observableMetadata.changed.connect(this.onGenericChange, this);
        const cell = options.cell;
        const trusted = this.modelDB.createValue('trusted');
        trusted.changed.connect(this.onTrustedChanged, this);
        if (!cell) {
            trusted.set(false);
            return;
        }
        trusted.set(!!cell.metadata['trusted']);
        delete cell.metadata['trusted'];
        if (Array.isArray(cell.source)) {
            this.value.text = cell.source.join('');
        }
        else {
            this.value.text = cell.source;
        }
        const metadata = JSONExt.deepCopy(cell.metadata);
        if (this.type !== 'raw') {
            delete metadata['format'];
        }
        if (this.type !== 'code') {
            delete metadata['collapsed'];
            delete metadata['scrolled'];
        }
        for (const key in metadata) {
            observableMetadata.set(key, metadata[key]);
        }
    }
    /**
     * The metadata associated with the cell.
     */
    get metadata() {
        return this.modelDB.get('metadata');
    }
    /**
     * Get the trusted state of the model.
     */
    get trusted() {
        return this.modelDB.getValue('trusted');
    }
    /**
     * Set the trusted state of the model.
     */
    set trusted(newValue) {
        const oldValue = this.trusted;
        if (oldValue === newValue) {
            return;
        }
        this.modelDB.setValue('trusted', newValue);
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const metadata = Object.create(null);
        for (const key of this.metadata.keys()) {
            const value = JSON.parse(JSON.stringify(this.metadata.get(key)));
            metadata[key] = value;
        }
        if (this.trusted) {
            metadata['trusted'] = true;
        }
        return {
            cell_type: this.type,
            source: this.value.text,
            metadata
        };
    }
    /**
     * Handle a change to the trusted state.
     *
     * The default implementation is a no-op.
     */
    onTrustedChanged(trusted, args) {
        /* no-op */
    }
    /**
     * Handle a change to the observable value.
     */
    onGenericChange() {
        this.contentChanged.emit(void 0);
    }
}
/**
 * A base implementation for cell models with attachments.
 */
export class AttachmentsCellModel extends CellModel {
    /**
     * Construct a new cell with optional attachments.
     */
    constructor(options) {
        super(options);
        const factory = options.contentFactory || AttachmentsCellModel.defaultContentFactory;
        let attachments;
        const cell = options.cell;
        if (cell && (cell.cell_type === 'raw' || cell.cell_type === 'markdown')) {
            attachments = cell
                .attachments;
        }
        this._attachments = factory.createAttachmentsModel({
            values: attachments,
            modelDB: this.modelDB
        });
        this._attachments.stateChanged.connect(this.onGenericChange, this);
    }
    /**
     * Get the attachments of the model.
     */
    get attachments() {
        return this._attachments;
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const cell = super.toJSON();
        if (this.attachments.length) {
            cell.attachments = this.attachments.toJSON();
        }
        return cell;
    }
}
/**
 * The namespace for `AttachmentsCellModel` statics.
 */
(function (AttachmentsCellModel) {
    /**
     * The default implementation of an `IContentFactory`.
     */
    class ContentFactory {
        /**
         * Create an attachments model.
         */
        createAttachmentsModel(options) {
            return new AttachmentsModel(options);
        }
    }
    AttachmentsCellModel.ContentFactory = ContentFactory;
    /**
     * The shared `ContentFactory` instance.
     */
    AttachmentsCellModel.defaultContentFactory = new ContentFactory();
})(AttachmentsCellModel || (AttachmentsCellModel = {}));
/**
 * An implementation of a raw cell model.
 */
export class RawCellModel extends AttachmentsCellModel {
    /**
     * The type of the cell.
     */
    get type() {
        return 'raw';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return super.toJSON();
    }
}
/**
 * An implementation of a markdown cell model.
 */
export class MarkdownCellModel extends AttachmentsCellModel {
    /**
     * Construct a markdown cell model from optional cell content.
     */
    constructor(options) {
        super(options);
        // Use the Github-flavored markdown mode.
        this.mimeType = 'text/x-ipythongfm';
    }
    /**
     * The type of the cell.
     */
    get type() {
        return 'markdown';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return super.toJSON();
    }
}
/**
 * An implementation of a code cell Model.
 */
export class CodeCellModel extends CellModel {
    /**
     * Construct a new code cell with optional original cell content.
     */
    constructor(options) {
        super(options);
        const factory = options.contentFactory || CodeCellModel.defaultContentFactory;
        const trusted = this.trusted;
        const cell = options.cell;
        let outputs = [];
        const executionCount = this.modelDB.createValue('executionCount');
        if (!executionCount.get()) {
            if (cell && cell.cell_type === 'code') {
                executionCount.set(cell.execution_count || null);
                outputs = cell.outputs;
            }
            else {
                executionCount.set(null);
            }
        }
        executionCount.changed.connect(this._onExecutionCountChanged, this);
        this._outputs = factory.createOutputArea({ trusted, values: outputs });
        this._outputs.changed.connect(this.onGenericChange, this);
        // We keep `collapsed` and `jupyter.outputs_hidden` metadata in sync, since
        // they are redundant in nbformat 4.4. See
        // https://github.com/jupyter/nbformat/issues/137
        this.metadata.changed.connect(Private.collapseChanged, this);
        // Sync `collapsed` and `jupyter.outputs_hidden` for the first time, giving
        // preference to `collapsed`.
        if (this.metadata.has('collapsed')) {
            const collapsed = this.metadata.get('collapsed');
            Private.collapseChanged(this.metadata, {
                type: 'change',
                key: 'collapsed',
                oldValue: collapsed,
                newValue: collapsed
            });
        }
        else if (this.metadata.has('jupyter')) {
            const jupyter = this.metadata.get('jupyter');
            if (jupyter.hasOwnProperty('outputs_hidden')) {
                Private.collapseChanged(this.metadata, {
                    type: 'change',
                    key: 'jupyter',
                    oldValue: jupyter,
                    newValue: jupyter
                });
            }
        }
    }
    /**
     * The type of the cell.
     */
    get type() {
        return 'code';
    }
    /**
     * The execution count of the cell.
     */
    get executionCount() {
        return this.modelDB.getValue('executionCount');
    }
    set executionCount(newValue) {
        const oldValue = this.executionCount;
        if (newValue === oldValue) {
            return;
        }
        this.modelDB.setValue('executionCount', newValue || null);
    }
    clearExecution() {
        this.outputs.clear();
        this.executionCount = null;
        this.metadata.delete('execution');
    }
    /**
     * The cell outputs.
     */
    get outputs() {
        return this._outputs;
    }
    /**
     * Dispose of the resources held by the model.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._outputs.dispose();
        this._outputs = null;
        super.dispose();
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const cell = super.toJSON();
        cell.execution_count = this.executionCount || null;
        cell.outputs = this.outputs.toJSON();
        return cell;
    }
    /**
     * Handle a change to the trusted state.
     */
    onTrustedChanged(trusted, args) {
        if (this._outputs) {
            this._outputs.trusted = args.newValue;
        }
        this.stateChanged.emit({
            name: 'trusted',
            oldValue: args.oldValue,
            newValue: args.newValue
        });
    }
    /**
     * Handle a change to the execution count.
     */
    _onExecutionCountChanged(count, args) {
        this.contentChanged.emit(void 0);
        this.stateChanged.emit({
            name: 'executionCount',
            oldValue: args.oldValue,
            newValue: args.newValue
        });
    }
}
/**
 * The namespace for `CodeCellModel` statics.
 */
(function (CodeCellModel) {
    /**
     * The default implementation of an `IContentFactory`.
     */
    class ContentFactory {
        /**
         * Create an output area.
         */
        createOutputArea(options) {
            return new OutputAreaModel(options);
        }
    }
    CodeCellModel.ContentFactory = ContentFactory;
    /**
     * The shared `ContentFactory` instance.
     */
    CodeCellModel.defaultContentFactory = new ContentFactory();
})(CodeCellModel || (CodeCellModel = {}));
var Private;
(function (Private) {
    function collapseChanged(metadata, args) {
        if (args.key === 'collapsed') {
            const jupyter = (metadata.get('jupyter') || {});
            const { outputs_hidden } = jupyter, newJupyter = __rest(jupyter, ["outputs_hidden"]);
            if (outputs_hidden !== args.newValue) {
                if (args.newValue !== undefined) {
                    newJupyter['outputs_hidden'] = args.newValue;
                }
                if (Object.keys(newJupyter).length === 0) {
                    metadata.delete('jupyter');
                }
                else {
                    metadata.set('jupyter', newJupyter);
                }
            }
        }
        else if (args.key === 'jupyter') {
            const jupyter = (args.newValue || {});
            if (jupyter.hasOwnProperty('outputs_hidden')) {
                metadata.set('collapsed', jupyter.outputs_hidden);
            }
            else {
                metadata.delete('collapsed');
            }
        }
    }
    Private.collapseChanged = collapseChanged;
})(Private || (Private = {}));
//# sourceMappingURL=model.js.map