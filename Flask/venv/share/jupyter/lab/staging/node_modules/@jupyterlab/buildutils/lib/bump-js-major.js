"use strict";
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = __importDefault(require("commander"));
const semver_1 = __importDefault(require("semver"));
const path_1 = __importDefault(require("path"));
const utils = __importStar(require("./utils"));
/**
 * Get the packages that depend on a given package, recursively.
 */
function getDeps(pkgName, lut) {
    const deps = new Set();
    for (const name in lut) {
        if ('@jupyterlab/' + pkgName in lut[name]) {
            const otherName = name.replace('@jupyterlab/', '');
            deps.add(otherName);
            const otherDeps = getDeps(otherName, lut);
            otherDeps.forEach(dep => {
                deps.add(dep);
            });
        }
    }
    return deps;
}
exports.getDeps = getDeps;
// Specify the program signature.
commander_1.default
    .description('Bump the major version of JS package(s)')
    .arguments('<package> [others...]')
    .option('--force', 'Force the upgrade')
    .option('--dry-run', 'Show what would be executed')
    .action((pkg, others, options) => {
    others.push(pkg);
    const toBump = new Set();
    const ignoreBump = new Set();
    const maybeBump = (pkg) => {
        if (pkg in toBump || pkg in ignoreBump) {
            return;
        }
        const version = utils.getJSVersion(pkg);
        if (semver_1.default.minor(version) === 0 && semver_1.default.prerelease(version)) {
            console.warn(`${pkg} has already been bumped`);
            ignoreBump.add(pkg);
        }
        else {
            toBump.add(pkg);
        }
    };
    others.forEach(pkg => {
        maybeBump(pkg);
    });
    // Create a lut of dependencies
    const lut = {};
    utils.getCorePaths().forEach(corePath => {
        const pkgDataPath = path_1.default.join(corePath, 'package.json');
        const data = utils.readJSONFile(pkgDataPath);
        lut[data.name] = data.dependencies || {};
    });
    // Look for dependencies of bumped packages
    Array.from(toBump).forEach(val => {
        const deps = getDeps(val, lut);
        deps.forEach(dep => {
            maybeBump(dep);
        });
    });
    if (!toBump.size) {
        console.warn('No packages found to bump!');
        return;
    }
    const pyVersion = utils.getPythonVersion();
    let preId = '';
    if (pyVersion.includes('a')) {
        preId = 'alpha';
    }
    else if (pyVersion.includes('rc')) {
        preId = 'rc';
    }
    else {
        throw new Error('Cannot bump JS packages until we switch to prerelease mode');
    }
    const pkgs = Array.from(toBump).join(',');
    let cmd = `lerna version premajor --preid=${preId} --force-publish=${pkgs} --no-push`;
    if (options.force) {
        cmd += ' --yes';
    }
    if (options.dryRun) {
        console.debug('Would run:');
        console.debug(cmd);
        return;
    }
    utils.run(cmd);
});
commander_1.default.parse(process.argv);
//# sourceMappingURL=bump-js-major.js.map