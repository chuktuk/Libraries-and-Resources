// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { ILabStatus, ILayoutRestorer } from '@jupyterlab/application';
import { Dialog, ISessionContextDialogs, ICommandPalette, sessionContextDialogs, showDialog, WidgetTracker } from '@jupyterlab/apputils';
import { IEditorServices } from '@jupyterlab/codeeditor';
import { ConsolePanel, IConsoleTracker } from '@jupyterlab/console';
import { PageConfig, URLExt } from '@jupyterlab/coreutils';
import { IFileBrowserFactory } from '@jupyterlab/filebrowser';
import { ILauncher } from '@jupyterlab/launcher';
import { IMainMenu } from '@jupyterlab/mainmenu';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { consoleIcon } from '@jupyterlab/ui-components';
import { find } from '@lumino/algorithm';
import { JSONExt, UUID } from '@lumino/coreutils';
import { DisposableSet } from '@lumino/disposable';
import { Menu } from '@lumino/widgets';
import foreign from './foreign';
/**
 * The command IDs used by the console plugin.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.create = 'console:create';
    CommandIDs.clear = 'console:clear';
    CommandIDs.runUnforced = 'console:run-unforced';
    CommandIDs.runForced = 'console:run-forced';
    CommandIDs.linebreak = 'console:linebreak';
    CommandIDs.interrupt = 'console:interrupt-kernel';
    CommandIDs.restart = 'console:restart-kernel';
    CommandIDs.closeAndShutdown = 'console:close-and-shutdown';
    CommandIDs.open = 'console:open';
    CommandIDs.inject = 'console:inject';
    CommandIDs.changeKernel = 'console:change-kernel';
    CommandIDs.enterToExecute = 'console:enter-to-execute';
    CommandIDs.shiftEnterToExecute = 'console:shift-enter-to-execute';
    CommandIDs.interactionMode = 'console:interaction-mode';
    CommandIDs.replaceSelection = 'console:replace-selection';
})(CommandIDs || (CommandIDs = {}));
/**
 * The console widget tracker provider.
 */
const tracker = {
    id: '@jupyterlab/console-extension:tracker',
    provides: IConsoleTracker,
    requires: [
        ConsolePanel.IContentFactory,
        IEditorServices,
        ILayoutRestorer,
        IFileBrowserFactory,
        IRenderMimeRegistry,
        ISettingRegistry
    ],
    optional: [
        IMainMenu,
        ICommandPalette,
        ILauncher,
        ILabStatus,
        ISessionContextDialogs
    ],
    activate: activateConsole,
    autoStart: true
};
/**
 * The console widget content factory.
 */
const factory = {
    id: '@jupyterlab/console-extension:factory',
    provides: ConsolePanel.IContentFactory,
    requires: [IEditorServices],
    autoStart: true,
    activate: (app, editorServices) => {
        const editorFactory = editorServices.factoryService.newInlineEditor;
        return new ConsolePanel.ContentFactory({ editorFactory });
    }
};
/**
 * Export the plugins as the default.
 */
const plugins = [factory, tracker, foreign];
export default plugins;
/**
 * Activate the console extension.
 */
async function activateConsole(app, contentFactory, editorServices, restorer, browserFactory, rendermime, settingRegistry, mainMenu, palette, launcher, status, sessionDialogs) {
    const manager = app.serviceManager;
    const { commands, shell } = app;
    const category = 'Console';
    sessionDialogs = (sessionDialogs !== null && sessionDialogs !== void 0 ? sessionDialogs : sessionContextDialogs);
    // Create a widget tracker for all console panels.
    const tracker = new WidgetTracker({
        namespace: 'console'
    });
    // Handle state restoration.
    void restorer.restore(tracker, {
        command: CommandIDs.create,
        args: widget => {
            const { path, name, kernelPreference } = widget.console.sessionContext;
            return {
                path,
                name,
                kernelPreference: Object.assign({}, kernelPreference)
            };
        },
        name: widget => { var _a; return _a = widget.console.sessionContext.path, (_a !== null && _a !== void 0 ? _a : UUID.uuid4()); },
        when: manager.ready
    });
    // Add a launcher item if the launcher is available.
    if (launcher) {
        void manager.ready.then(() => {
            let disposables = null;
            const onSpecsChanged = () => {
                if (disposables) {
                    disposables.dispose();
                    disposables = null;
                }
                const specs = manager.kernelspecs.specs;
                if (!specs) {
                    return;
                }
                disposables = new DisposableSet();
                const baseUrl = PageConfig.getBaseUrl();
                for (const name in specs.kernelspecs) {
                    const rank = name === specs.default ? 0 : Infinity;
                    const spec = specs.kernelspecs[name];
                    let kernelIconUrl = spec.resources['logo-64x64'];
                    if (kernelIconUrl) {
                        const index = kernelIconUrl.indexOf('kernelspecs');
                        kernelIconUrl = URLExt.join(baseUrl, kernelIconUrl.slice(index));
                    }
                    disposables.add(launcher.add({
                        command: CommandIDs.create,
                        args: { isLauncher: true, kernelPreference: { name } },
                        category: 'Console',
                        rank,
                        kernelIconUrl,
                        metadata: {
                            kernel: JSONExt.deepCopy(spec.metadata || {})
                        }
                    }));
                }
            };
            onSpecsChanged();
            manager.kernelspecs.specsChanged.connect(onSpecsChanged);
        });
    }
    /**
     * Create a console for a given path.
     */
    async function createConsole(options) {
        var _a;
        await manager.ready;
        const panel = new ConsolePanel(Object.assign({ manager,
            contentFactory, mimeTypeService: editorServices.mimeTypeService, rendermime, setBusy: (_a = (status && (() => status.setBusy())), (_a !== null && _a !== void 0 ? _a : undefined)) }, options));
        const interactionMode = (await settingRegistry.get('@jupyterlab/console-extension:tracker', 'interactionMode')).composite;
        panel.console.node.dataset.jpInteractionMode = interactionMode;
        // Add the console panel to the tracker. We want the panel to show up before
        // any kernel selection dialog, so we do not await panel.session.ready;
        await tracker.add(panel);
        panel.sessionContext.propertyChanged.connect(() => {
            void tracker.save(panel);
        });
        shell.add(panel, 'main', {
            ref: options.ref,
            mode: options.insertMode,
            activate: options.activate !== false
        });
        return panel;
    }
    const pluginId = '@jupyterlab/console-extension:tracker';
    let interactionMode;
    async function updateSettings() {
        interactionMode = (await settingRegistry.get(pluginId, 'interactionMode'))
            .composite;
        tracker.forEach(widget => {
            widget.console.node.dataset.jpInteractionMode = interactionMode;
        });
    }
    settingRegistry.pluginChanged.connect((sender, plugin) => {
        if (plugin === pluginId) {
            void updateSettings();
        }
    });
    await updateSettings();
    /**
     * Whether there is an active console.
     */
    function isEnabled() {
        return (tracker.currentWidget !== null &&
            tracker.currentWidget === shell.currentWidget);
    }
    let command = CommandIDs.open;
    commands.addCommand(command, {
        execute: (args) => {
            const path = args['path'];
            const widget = tracker.find(value => {
                var _a;
                return ((_a = value.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path) === path;
            });
            if (widget) {
                if (args.activate !== false) {
                    shell.activateById(widget.id);
                }
                return widget;
            }
            else {
                return manager.ready.then(() => {
                    const model = find(manager.sessions.running(), item => {
                        return item.path === path;
                    });
                    if (model) {
                        return createConsole(args);
                    }
                    return Promise.reject(`No running kernel session for path: ${path}`);
                });
            }
        }
    });
    command = CommandIDs.create;
    commands.addCommand(command, {
        label: args => {
            var _a, _b, _c, _d;
            if (args['isPalette']) {
                return 'New Console';
            }
            else if (args['isLauncher'] && args['kernelPreference']) {
                const kernelPreference = args['kernelPreference'];
                // TODO: Lumino command functions should probably be allowed to return undefined?
                return (_d = (_c = (_b = (_a = manager.kernelspecs) === null || _a === void 0 ? void 0 : _a.specs) === null || _b === void 0 ? void 0 : _b.kernelspecs[kernelPreference.name || '']) === null || _c === void 0 ? void 0 : _c.display_name, (_d !== null && _d !== void 0 ? _d : ''));
            }
            return 'Console';
        },
        icon: args => (args['isPalette'] ? undefined : consoleIcon),
        execute: args => {
            const basePath = args['basePath'] ||
                args['cwd'] ||
                browserFactory.defaultBrowser.model.path;
            return createConsole(Object.assign({ basePath }, args));
        }
    });
    // Get the current widget and activate unless the args specify otherwise.
    function getCurrent(args) {
        const widget = tracker.currentWidget;
        const activate = args['activate'] !== false;
        if (activate && widget) {
            shell.activateById(widget.id);
        }
        return (widget !== null && widget !== void 0 ? widget : null);
    }
    commands.addCommand(CommandIDs.clear, {
        label: 'Clear Console Cells',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            current.console.clear();
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.runUnforced, {
        label: 'Run Cell (unforced)',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            return current.console.execute();
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.runForced, {
        label: 'Run Cell (forced)',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            return current.console.execute(true);
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.linebreak, {
        label: 'Insert Line Break',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            current.console.insertLinebreak();
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.replaceSelection, {
        label: 'Replace Selection in Console',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            const text = args['text'] || '';
            current.console.replaceSelection(text);
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.interrupt, {
        label: 'Interrupt Kernel',
        execute: args => {
            var _a;
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            const kernel = (_a = current.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
            if (kernel) {
                return kernel.interrupt();
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.restart, {
        label: 'Restart Kernel…',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            return sessionDialogs.restart(current.console.sessionContext);
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.closeAndShutdown, {
        label: 'Close and Shut Down…',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            return showDialog({
                title: 'Shut down the console?',
                body: `Are you sure you want to close "${current.title.label}"?`,
                buttons: [Dialog.cancelButton(), Dialog.warnButton()]
            }).then(result => {
                if (result.button.accept) {
                    return current.console.sessionContext.shutdown().then(() => {
                        current.dispose();
                        return true;
                    });
                }
                else {
                    return false;
                }
            });
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.inject, {
        execute: args => {
            const path = args['path'];
            tracker.find(widget => {
                var _a;
                if (((_a = widget.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path) === path) {
                    if (args['activate'] !== false) {
                        shell.activateById(widget.id);
                    }
                    void widget.console.inject(args['code'], args['metadata']);
                    return true;
                }
                return false;
            });
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.changeKernel, {
        label: 'Change Kernel…',
        execute: args => {
            const current = getCurrent(args);
            if (!current) {
                return;
            }
            return sessionDialogs.selectKernel(current.console.sessionContext);
        },
        isEnabled
    });
    if (palette) {
        // Add command palette items
        [
            CommandIDs.create,
            CommandIDs.linebreak,
            CommandIDs.clear,
            CommandIDs.runUnforced,
            CommandIDs.runForced,
            CommandIDs.restart,
            CommandIDs.interrupt,
            CommandIDs.changeKernel,
            CommandIDs.closeAndShutdown
        ].forEach(command => {
            palette.addItem({ command, category, args: { isPalette: true } });
        });
    }
    if (mainMenu) {
        // Add a console creator to the File menu
        mainMenu.fileMenu.newMenu.addGroup([{ command: CommandIDs.create }], 0);
        // Add a close and shutdown command to the file menu.
        mainMenu.fileMenu.closeAndCleaners.add({
            tracker,
            action: 'Shutdown',
            name: 'Console',
            closeAndCleanup: (current) => {
                return showDialog({
                    title: 'Shut down the console?',
                    body: `Are you sure you want to close "${current.title.label}"?`,
                    buttons: [Dialog.cancelButton(), Dialog.warnButton()]
                }).then(result => {
                    if (result.button.accept) {
                        return current.console.sessionContext.shutdown().then(() => {
                            current.dispose();
                        });
                    }
                    else {
                        return void 0;
                    }
                });
            }
        });
        // Add a kernel user to the Kernel menu
        mainMenu.kernelMenu.kernelUsers.add({
            tracker,
            interruptKernel: current => {
                var _a;
                const kernel = (_a = current.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
                if (kernel) {
                    return kernel.interrupt();
                }
                return Promise.resolve(void 0);
            },
            noun: 'Console',
            restartKernel: current => sessionDialogs.restart(current.console.sessionContext),
            restartKernelAndClear: current => {
                return sessionDialogs
                    .restart(current.console.sessionContext)
                    .then(restarted => {
                    if (restarted) {
                        current.console.clear();
                    }
                    return restarted;
                });
            },
            changeKernel: current => sessionDialogs.selectKernel(current.console.sessionContext),
            shutdownKernel: current => current.console.sessionContext.shutdown()
        });
        // Add a code runner to the Run menu.
        mainMenu.runMenu.codeRunners.add({
            tracker,
            noun: 'Cell',
            pluralNoun: 'Cells',
            run: current => current.console.execute(true)
        });
        // Add a clearer to the edit menu
        mainMenu.editMenu.clearers.add({
            tracker,
            noun: 'Console Cells',
            clearCurrent: (current) => {
                return current.console.clear();
            }
        });
    }
    // For backwards compatibility and clarity, we explicitly label the run
    // keystroke with the actual effected change, rather than the generic
    // "notebook" or "terminal" interaction mode. When this interaction mode
    // affects more than just the run keystroke, we can make this menu title more
    // generic.
    const runShortcutTitles = {
        notebook: 'Execute with Shift+Enter',
        terminal: 'Execute with Enter'
    };
    // Add the execute keystroke setting submenu.
    commands.addCommand(CommandIDs.interactionMode, {
        label: args => runShortcutTitles[args['interactionMode']] || '',
        execute: async (args) => {
            const key = 'keyMap';
            try {
                await settingRegistry.set(pluginId, 'interactionMode', args['interactionMode']);
            }
            catch (reason) {
                console.error(`Failed to set ${pluginId}:${key} - ${reason.message}`);
            }
        },
        isToggled: args => args['interactionMode'] === interactionMode
    });
    const executeMenu = new Menu({ commands });
    executeMenu.title.label = 'Console Run Keystroke';
    ['terminal', 'notebook'].forEach(name => executeMenu.addItem({
        command: CommandIDs.interactionMode,
        args: { interactionMode: name }
    }));
    if (mainMenu) {
        mainMenu.settingsMenu.addGroup([
            {
                type: 'submenu',
                submenu: executeMenu
            }
        ], 10);
        // Add kernel information to the application help menu.
        mainMenu.helpMenu.kernelUsers.add({
            tracker,
            getKernel: current => { var _a; return (_a = current.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel; }
        });
    }
    app.contextMenu.addItem({
        command: CommandIDs.clear,
        selector: '.jp-CodeConsole-content'
    });
    app.contextMenu.addItem({
        command: CommandIDs.restart,
        selector: '.jp-CodeConsole'
    });
    return tracker;
}
//# sourceMappingURL=index.js.map