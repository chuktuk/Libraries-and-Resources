// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { ILabShell, ILayoutRestorer } from '@jupyterlab/application';
import { CommandToolbarButton, ICommandPalette, MainAreaWidget, WidgetTracker, ReactWidget } from '@jupyterlab/apputils';
import { ILoggerRegistry, LogConsolePanel, LoggerRegistry } from '@jupyterlab/logconsole';
import { IMainMenu } from '@jupyterlab/mainmenu';
import { INotebookTracker } from '@jupyterlab/notebook';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { IStatusBar } from '@jupyterlab/statusbar';
import { addIcon, clearIcon, HTMLSelect, listIcon } from '@jupyterlab/ui-components';
import { UUID } from '@lumino/coreutils';
import * as React from 'react';
import { logNotebookOutput } from './nboutput';
import { LogConsoleStatus } from './status';
const LOG_CONSOLE_PLUGIN_ID = '@jupyterlab/logconsole-extension:plugin';
/**
 * The command IDs used by the plugin.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.addCheckpoint = 'logconsole:add-checkpoint';
    CommandIDs.clear = 'logconsole:clear';
    CommandIDs.open = 'logconsole:open';
    CommandIDs.setLevel = 'logconsole:set-level';
})(CommandIDs || (CommandIDs = {}));
/**
 * The Log Console extension.
 */
const logConsolePlugin = {
    activate: activateLogConsole,
    id: LOG_CONSOLE_PLUGIN_ID,
    provides: ILoggerRegistry,
    requires: [ILabShell, IRenderMimeRegistry, INotebookTracker],
    optional: [
        ICommandPalette,
        ILayoutRestorer,
        IMainMenu,
        ISettingRegistry,
        IStatusBar
    ],
    autoStart: true
};
/**
 * Activate the Log Console extension.
 */
function activateLogConsole(app, labShell, rendermime, nbtracker, palette, restorer, mainMenu, settingRegistry, statusBar) {
    let logConsoleWidget = null;
    let logConsolePanel = null;
    const loggerRegistry = new LoggerRegistry({
        defaultRendermime: rendermime,
        // The maxLength is reset below from settings
        maxLength: 1000
    });
    const tracker = new WidgetTracker({
        namespace: 'logconsole'
    });
    if (restorer) {
        void restorer.restore(tracker, {
            command: CommandIDs.open,
            name: () => 'logconsole'
        });
    }
    const status = new LogConsoleStatus({
        loggerRegistry: loggerRegistry,
        handleClick: () => {
            var _a;
            if (!logConsoleWidget) {
                createLogConsoleWidget({
                    insertMode: 'split-bottom',
                    ref: (_a = app.shell.currentWidget) === null || _a === void 0 ? void 0 : _a.id
                });
            }
            else {
                app.shell.activateById(logConsoleWidget.id);
            }
        }
    });
    const createLogConsoleWidget = (options = {}) => {
        logConsolePanel = new LogConsolePanel(loggerRegistry);
        logConsolePanel.source =
            options.source !== undefined
                ? options.source
                : nbtracker.currentWidget
                    ? nbtracker.currentWidget.context.path
                    : null;
        logConsoleWidget = new MainAreaWidget({ content: logConsolePanel });
        logConsoleWidget.addClass('jp-LogConsole');
        logConsoleWidget.title.closable = true;
        logConsoleWidget.title.icon = listIcon;
        logConsoleWidget.title.label = 'Log Console';
        const addCheckpointButton = new CommandToolbarButton({
            commands: app.commands,
            id: CommandIDs.addCheckpoint
        });
        const clearButton = new CommandToolbarButton({
            commands: app.commands,
            id: CommandIDs.clear
        });
        logConsoleWidget.toolbar.addItem('lab-log-console-add-checkpoint', addCheckpointButton);
        logConsoleWidget.toolbar.addItem('lab-log-console-clear', clearButton);
        logConsoleWidget.toolbar.addItem('level', new LogLevelSwitcher(logConsoleWidget.content));
        logConsolePanel.sourceChanged.connect(() => {
            app.commands.notifyCommandChanged();
        });
        logConsolePanel.sourceDisplayed.connect((panel, { source, version }) => {
            status.model.sourceDisplayed(source, version);
        });
        logConsoleWidget.disposed.connect(() => {
            logConsoleWidget = null;
            logConsolePanel = null;
            app.commands.notifyCommandChanged();
        });
        app.shell.add(logConsoleWidget, 'main', {
            ref: options.ref,
            mode: options.insertMode
        });
        void tracker.add(logConsoleWidget);
        logConsoleWidget.update();
        app.commands.notifyCommandChanged();
    };
    app.commands.addCommand(CommandIDs.open, {
        label: 'Show Log Console',
        execute: (options = {}) => {
            // Toggle the display
            if (logConsoleWidget) {
                logConsoleWidget.dispose();
            }
            else {
                createLogConsoleWidget(options);
            }
        },
        isToggled: () => {
            return logConsoleWidget !== null;
        }
    });
    app.commands.addCommand(CommandIDs.addCheckpoint, {
        execute: () => {
            var _a, _b;
            (_b = (_a = logConsolePanel) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.checkpoint();
        },
        icon: addIcon,
        isEnabled: () => !!logConsolePanel && logConsolePanel.source !== null,
        label: 'Add Checkpoint'
    });
    app.commands.addCommand(CommandIDs.clear, {
        execute: () => {
            var _a, _b;
            (_b = (_a = logConsolePanel) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.clear();
        },
        icon: clearIcon,
        isEnabled: () => !!logConsolePanel && logConsolePanel.source !== null,
        label: 'Clear Log'
    });
    function toTitleCase(value) {
        return value.length === 0 ? value : value[0].toUpperCase() + value.slice(1);
    }
    app.commands.addCommand(CommandIDs.setLevel, {
        // TODO: find good icon class
        execute: (args) => {
            var _a;
            if ((_a = logConsolePanel) === null || _a === void 0 ? void 0 : _a.logger) {
                logConsolePanel.logger.level = args.level;
            }
        },
        isEnabled: () => !!logConsolePanel && logConsolePanel.source !== null,
        label: args => `Set Log Level to ${toTitleCase(args.level)}`
    });
    app.contextMenu.addItem({
        command: CommandIDs.open,
        selector: '.jp-Notebook'
    });
    if (mainMenu) {
        mainMenu.viewMenu.addGroup([{ command: CommandIDs.open }]);
    }
    if (palette) {
        palette.addItem({ command: CommandIDs.open, category: 'Main Area' });
    }
    if (statusBar) {
        statusBar.registerStatusItem('@jupyterlab/logconsole-extension:status', {
            item: status,
            align: 'left',
            isActive: () => true,
            activeStateChanged: status.model.stateChanged
        });
    }
    function setSource(newValue) {
        if (logConsoleWidget && newValue === logConsoleWidget) {
            // Do not change anything if we are just focusing on ourselves
            return;
        }
        let source;
        if (newValue && nbtracker.has(newValue)) {
            source = newValue.context.path;
        }
        else {
            source = null;
        }
        if (logConsolePanel) {
            logConsolePanel.source = source;
        }
        status.model.source = source;
    }
    void app.restored.then(() => {
        // Set source only after app is restored in order to allow restorer to
        // restore previous source first, which may set the renderer
        setSource(labShell.currentWidget);
        labShell.currentChanged.connect((_, { newValue }) => setSource(newValue));
    });
    if (settingRegistry) {
        const updateSettings = (settings) => {
            loggerRegistry.maxLength = settings.get('maxLogEntries')
                .composite;
            status.model.flashEnabled = settings.get('flash').composite;
        };
        Promise.all([settingRegistry.load(LOG_CONSOLE_PLUGIN_ID), app.restored])
            .then(([settings]) => {
            updateSettings(settings);
            settings.changed.connect(settings => {
                updateSettings(settings);
            });
        })
            .catch((reason) => {
            console.error(reason.message);
        });
    }
    return loggerRegistry;
}
/**
 * A toolbar widget that switches log levels.
 */
export class LogLevelSwitcher extends ReactWidget {
    /**
     * Construct a new cell type switcher.
     */
    constructor(widget) {
        super();
        /**
         * Handle `change` events for the HTMLSelect component.
         */
        this.handleChange = (event) => {
            if (this._logConsole.logger) {
                this._logConsole.logger.level = event.target.value;
            }
            this.update();
        };
        /**
         * Handle `keydown` events for the HTMLSelect component.
         */
        this.handleKeyDown = (event) => {
            if (event.keyCode === 13) {
                this._logConsole.activate();
            }
        };
        this._id = `level-${UUID.uuid4()}`;
        this.addClass('jp-LogConsole-toolbarLogLevel');
        this._logConsole = widget;
        if (widget.source) {
            this.update();
        }
        widget.sourceChanged.connect(this._updateSource, this);
    }
    _updateSource(sender, { oldValue, newValue }) {
        // Transfer stateChanged handler to new source logger
        if (oldValue !== null) {
            const logger = sender.loggerRegistry.getLogger(oldValue);
            logger.stateChanged.disconnect(this.update, this);
        }
        if (newValue !== null) {
            const logger = sender.loggerRegistry.getLogger(newValue);
            logger.stateChanged.connect(this.update, this);
        }
        this.update();
    }
    render() {
        var _a;
        const logger = this._logConsole.logger;
        return (React.createElement(React.Fragment, null,
            React.createElement("label", { htmlFor: this._id, className: logger === null
                    ? 'jp-LogConsole-toolbarLogLevel-disabled'
                    : undefined }, "Log Level:"),
            React.createElement(HTMLSelect, { id: this._id, className: "jp-LogConsole-toolbarLogLevelDropdown", onChange: this.handleChange, onKeyDown: this.handleKeyDown, value: (_a = logger) === null || _a === void 0 ? void 0 : _a.level, "aria-label": "Log level", disabled: logger === null, options: logger === null
                    ? []
                    : [
                        'Critical',
                        'Error',
                        'Warning',
                        'Info',
                        'Debug'
                    ].map(label => ({ label, value: label.toLowerCase() })) })));
    }
}
export default [logConsolePlugin, logNotebookOutput];
//# sourceMappingURL=index.js.map