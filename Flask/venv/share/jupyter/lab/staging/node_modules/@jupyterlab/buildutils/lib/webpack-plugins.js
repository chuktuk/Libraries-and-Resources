"use strict";
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const DuplicatePackageCheckerPlugin = require("duplicate-package-checker-webpack-plugin");
const fs = __importStar(require("fs-extra"));
const webpack = __importStar(require("webpack"));
var WPPlugin;
(function (WPPlugin) {
    /**
     * A WebPack Plugin that copies the assets to the static directory
     */
    class FrontEndPlugin {
        constructor(buildDir, staticDir) {
            this.buildDir = buildDir;
            this.staticDir = staticDir;
            this._first = true;
        }
        apply(compiler) {
            compiler.hooks.afterEmit.tap('FrontEndPlugin', () => {
                // bail if no staticDir
                if (!this.staticDir) {
                    return;
                }
                // ensure a clean static directory on the first emit
                if (this._first && fs.existsSync(this.staticDir)) {
                    fs.removeSync(this.staticDir);
                }
                this._first = false;
                fs.copySync(this.buildDir, this.staticDir);
            });
        }
    }
    WPPlugin.FrontEndPlugin = FrontEndPlugin;
    /**
     * A WebPack Plugin that ignores files that are filtered by a callback
     */
    class FilterIgnorePlugin extends webpack.IgnorePlugin {
        constructor(ignored) {
            super({});
            // ignored should be a callback function that filters the build files
            this.ignored = ignored;
        }
        checkIgnore(result) {
            if (!result) {
                return result;
            }
            return this.ignored(result.resource) ? result : null;
        }
    }
    WPPlugin.FilterIgnorePlugin = FilterIgnorePlugin;
    /**
     * A helper class for the WatchIgnoreFilterPlugin. This is a close copy of
     * (the non-exported) webpack.IgnoringWatchFileSystem
     */
    class FilterIgnoringWatchFileSystem {
        constructor(wfs, ignored) {
            this.wfs = wfs;
            // ignored should be a callback function that filters the build files
            this.ignored = ignored;
        }
        watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
            const notIgnored = (path) => !this.ignored(path);
            const ignoredFiles = files.filter(this.ignored);
            const ignoredDirs = dirs.filter(this.ignored);
            const watcher = this.wfs.watch(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps, removedFiles) => {
                if (err) {
                    return callback(err);
                }
                for (const path of ignoredFiles) {
                    fileTimestamps.set(path, 1);
                }
                for (const path of ignoredDirs) {
                    dirTimestamps.set(path, 1);
                }
                callback(err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps, removedFiles);
            }, callbackUndelayed);
            return {
                close: () => watcher.close(),
                pause: () => watcher.pause(),
                getContextTimestamps: () => {
                    const dirTimestamps = watcher.getContextTimestamps();
                    for (const path of ignoredDirs) {
                        dirTimestamps.set(path, 1);
                    }
                    return dirTimestamps;
                },
                getFileTimestamps: () => {
                    const fileTimestamps = watcher.getFileTimestamps();
                    for (const path of ignoredFiles) {
                        fileTimestamps.set(path, 1);
                    }
                    return fileTimestamps;
                }
            };
        }
    }
    /**
     * A WebPack Plugin that ignores files files that are filtered
     * by a callback during a `--watch` build
     */
    class FilterWatchIgnorePlugin {
        constructor(ignored) {
            this.ignored = ignored;
        }
        apply(compiler) {
            compiler.hooks.afterEnvironment.tap('FilterWatchIgnorePlugin', () => {
                compiler.watchFileSystem = new FilterIgnoringWatchFileSystem(compiler.watchFileSystem, this.ignored);
            });
        }
    }
    WPPlugin.FilterWatchIgnorePlugin = FilterWatchIgnorePlugin;
    class NowatchDuplicatePackageCheckerPlugin extends DuplicatePackageCheckerPlugin {
        apply(compiler) {
            const options = this.options;
            compiler.hooks.run.tap('NowatchDuplicatePackageCheckerPlugin', (compiler) => {
                const p = new DuplicatePackageCheckerPlugin(options);
                p.apply(compiler);
            });
        }
    }
    WPPlugin.NowatchDuplicatePackageCheckerPlugin = NowatchDuplicatePackageCheckerPlugin;
})(WPPlugin = exports.WPPlugin || (exports.WPPlugin = {}));
//# sourceMappingURL=webpack-plugins.js.map