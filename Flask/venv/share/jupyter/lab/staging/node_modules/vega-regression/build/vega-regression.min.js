!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("vega-statistics"),require("vega-dataflow"),require("vega-util")):"function"==typeof define&&define.amd?define(["exports","vega-statistics","vega-dataflow","vega-util"],r):r(((e=e||self).vega=e.vega||{},e.vega.transforms={}),e.vega,e.vega,e.vega)}(this,(function(e,r,a,t){"use strict";function n(e,r){var a,t,n,s,i,o,u=[],l=function(e){return e(s)};if(null==r)u.push(e);else for(a={},t=0,n=e.length;t<n;++t)s=e[t],(o=a[i=r.map(l)])||(a[i]=o=[],o.dims=i,u.push(o)),o.push(s);return u}function s(e){a.Transform.call(this,null,e)}s.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:!0}]},t.inherits(s,a.Transform).transform=function(e,s){var i=s.fork(s.NO_SOURCE|s.NO_FIELDS);if(!this.value||s.changed()||e.modified()){const o=n(s.materialize(s.SOURCE).source,e.groupby),u=(e.groupby||[]).map(t.accessorName),l=u.length,d=e.as||[t.accessorName(e.x),t.accessorName(e.y)],f=[];o.forEach(t=>{r.regressionLoess(t,e.x,e.y,e.bandwidth||.3).forEach(e=>{const r={};for(let e=0;e<l;++e)r[u[e]]=t.dims[e];r[d[0]]=e[0],r[d[1]]=e[1],f.push(a.ingest(r))})}),this.value&&(i.rem=this.value),this.value=i.add=i.source=f}return i};const i={linear:r.regressionLinear,log:r.regressionLog,exp:r.regressionExp,pow:r.regressionPow,quad:r.regressionQuad,poly:r.regressionPoly};function o(e){a.Transform.call(this,null,e)}o.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",type:"string",default:"linear",values:Object.keys(i)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean",default:!1},{name:"as",type:"string",array:!0}]},t.inherits(o,a.Transform).transform=function(e,s){var o=s.fork(s.NO_SOURCE|s.NO_FIELDS);if(!this.value||s.changed()||e.modified()){const u=n(s.materialize(s.SOURCE).source,e.groupby),l=(e.groupby||[]).map(t.accessorName),d=e.method||"linear",f=e.order||3,m=function(e,r){return"poly"===e?r:"quad"===e?2:1}(d,f),p=e.as||[t.accessorName(e.x),t.accessorName(e.y)],c=i[d],g=[];let y=e.extent;t.hasOwnProperty(i,d)||t.error("Invalid regression method: "+d),null!=y&&"log"===d&&y[0]<=0&&(s.dataflow.warn("Ignoring extent with values <= 0 for log regression."),y=null),u.forEach(n=>{if(n.length<=m)return void s.dataflow.warn("Skipping regression with more parameters than data points.");const i=c(n,e.x,e.y,f);if(e.params)return void g.push(a.ingest({keys:n.dims,coef:i.coef,rSquared:i.rSquared}));const o=y||t.extent(n,e.x),u=e=>{const r={};for(let e=0;e<l.length;++e)r[l[e]]=n.dims[e];r[p[0]]=e[0],r[p[1]]=e[1],g.push(a.ingest(r))};"linear"===d?o.forEach(e=>u([e,i.predict(e)])):r.sampleCurve(i.predict,o,25,200).forEach(u)}),this.value&&(o.rem=this.value),this.value=o.add=o.source=g}return o},e.loess=s,e.regression=o,Object.defineProperty(e,"__esModule",{value:!0})}));