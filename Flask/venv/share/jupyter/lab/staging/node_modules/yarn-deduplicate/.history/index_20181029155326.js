const lockfile = require('@yarnpkg/lockfile')
const semver = require('semver');

const parseYarnLock = (file) => lockfile.parse(file).object;

const extractPackages = (json) => {
    const packages={};
    const re = /^(.*)@([^@]*?)$/;

    Object.keys(json).forEach((name) => {
        const pkg = json[name];
        const match = name.match(re);

        let packageName, requestedVersion;
        // TODO: make this ignore other urls like:
        //      git...
        //      user/repo
        //      tag
        //      path/path/path
        if (match) {
            ([, packageName, requestedVersion] = match);
        } else {
            // If there is no match, it means there is no version specified. According to the doc
            // this means "*" (https://docs.npmjs.com/files/package.json#dependencies)
            packageName = name;
            requestedVersion = "*";
        }

        packages[packageName] = packages[packageName] || [];
        packages[packageName].push({
            pkg,
            requestedVersion,
            satisfiedBy: new Set(),
        });
    });
    return packages;
}

/**
 * Generates a map with all the versions installed for a pcakge
 * Example output:
 *
 * {
 *   "1.2.0": {
 *     pkg: <package object>
 *     satisfies: Set of package instances that satisfies this version
 *   }
 * }
 *
 * @param packages List of ppackages, as produced by `extractPackages`
 * @param name Package to look for
 */
const getPackageIntances = (packages, name, useMostCommon) => {
    // Instances of this package in the tree
    const packageInstances = packages[name];

    // Extract the list of unique versions
    const versions = packageInstances.reduce((versions, packageInstance) => {
        // Do not process the same version again
        if ((packageInstance.pkg.version in versions)) return versions;
        versions[packageInstance.pkg.version] = {
            pkg: packageInstance.pkg,
            satisfies: new Set(),
        }
        return versions;
    }, {});

    // Link each version with all the package instances it satisfies
    Object.keys(versions).forEach(version => {
        const satisfies = versions[version].satisfies;
        packageInstances.forEach(packageInstance => {
            if (semver.satisfies(version, packageInstance.requestedVersion)) {
                satisfies.add(packageInstance);
                packageInstance.satisfiedBy.add(version);
            }
        })
    })

    packageInstances.forEach(packageInstance => {
        const candidateVersions = Array.from(packageInstance.satisfiedBy);
        candidateVersions.sort((versionA, versionB) => {
            if (useMostCommon) {
                // Sort verions based on how many packages it satisfies. In case of a tie, put the
                // highest version first.
                if (versions[versionB].satisfies.size > versions[versionA].satisfies.size) return 1;
                if (versions[versionB].satisfies.size < versions[versionA].satisfies.size) return -1;
            }
            return semver.rcompare(versionA, versionB);
        });
        packageInstance.satisfiedBy = candidateVersions;
    });

    return packageInstances;
}

module.exports.listDuplicates = (yarnLock, {
    includePackages=[],
    useMostCommon=false,
}={}) => {
    const json = parseYarnLock(yarnLock);
    const packages = extractPackages(json);
    const result = [];

    Object.keys(packages)
        // Filter out packages not specified in the inclusion list
        .filter((name) => {
            if (includePackages.length === 0) return true;
            return includePackages.includes(name);
        })
        .reduce((acc, name) => acc.concat(getPackageIntances(packages, name, useMostCommon), [])
        .forEach(packageInstances => {
            // Map every package instance to the deduped version
            packageInstances.forEach(packageInstance => {
                const candidateVersions = packageInstance.satisfiedBy;

                // The best package is always the first one in the list thanks to the sorting.
                const bestVersion = candidateVersions[0];
                if (bestVersion !== packageInstance.pkg.version) {
                    result.push(`Package "${name}" wants ${packageInstance.requestedVersion} and could get ${bestVersion}, but got ${packageInstance.pkg.version}`);
                }
            })
        })

    return result;
}

module.exports.fixDuplicates = (yarnLock, {
    includePackages=[],
    useMostCommon=false,
}={}) => {
    const json = parseYarnLock(yarnLock);
    const packages = extractPackages(json);
    const log = [];

    Object.keys(packages)
        // Filter out packages not specified in the inclusion list
        .filter((name) => {
            if (includePackages.length === 0) return true;
            return includePackages.includes(name);
        })
        .forEach((name) => {
            const packageInstances = packages[name];

            // Create a map with all versions installed for this package
            const versions = packageInstances.reduce((versions, packageInstance) => {
                // Do not process the same version again
                if ((packageInstance.pkg.version in versions)) return versions;
                versions[packageInstance.pkg.version] = {
                    pkg: packageInstance.pkg,
                    satisfies: new Set(),
                }
                return versions;
            }, {});

            // Link each version with all the package instances it satisfies
            Object.keys(versions).forEach(version => {
                const satisfies = versions[version].satisfies;
                packageInstances.forEach(packageInstance => {
                    if (semver.satisfies(version, packageInstance.requestedVersion)) {
                        satisfies.add(packageInstance);
                        packageInstance.satisfiedBy.add(version);
                    }
                })
            })

            // Map every package instance to the deduped version
            packageInstances.forEach(packageInstance => {
                const candidateVersions = Array.from(packageInstance.satisfiedBy);

                candidateVersions.sort((versionA, versionB) => {
                    if (useMostCommon) {
                        // Sort verions based on how many packages it satisfies. In case of a tie, put the
                        // highest version first.
                        if (versions[versionB].satisfies.size > versions[versionA].satisfies.size) return 1;
                        if (versions[versionB].satisfies.size < versions[versionA].satisfies.size) return -1;
                    }
                    return semver.rcompare(versionA, versionB);
                });

                // The best package is always the first one in the list thanks to the sorting above.
                const bestVersion = candidateVersions[0];
                if (bestVersion !== packageInstance.pkg.version) {
                    log.push(`Package "${name}" wants ${packageInstance.requestedVersion} and could get ${bestVersion}, but got ${packageInstance.pkg.version}`);
                    json[`${name}@${packageInstance.requestedVersion}`] = versions[bestVersion].pkg;
                }
            })
        });

    return lockfile.stringify(json);
}

