---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
```{r}

```

# RStudio Projects
- Collection of files, data, results, graphs, etc.
- File -> new project
  - can create a project directly to a github directory too




```{r}

```

# Variables
You can use '=' or the assignment operator <- to define variables.
Variable names can include `.` in them

If necessary use
`assign('var', val)` where 'var' is the variable and val is the value. The variable name must be in quotes.

`rm(a)` to remove a variable from memory
```{r}
c <- 4
b = 2
d = c * b
d
```

# Data Types
- numeric
- character (string)
- Date/POSIXct(time-based)
- logical (TRUE/FALSE)

- Check datatype with the `class(x)` function



```{r}

```


# Logical operators are the same as python
`==`
`!=`
`>`
`<`
`>=`
`<=`
```{r}
b > c
```
# Character Data (Strings)
- single or double quotes

# Functions
`nchar(x)` for the number of characters or number of digits for numeric data (does not work on factors)



```{r}
s <- 'This is a string.'
t <- "So is this."
print(s)
print(t)
```

# Numeric Data

# Mathematical operations

use `^` instead of `**` to do exponents

`sqrt(x)` -- if multiple items, will sqrt all of them
`log(x)`
`sum(x, y)` -- sums all numbers within
`mean(x, y,...)`
`length(x, y, ...)` returns the number of objects in ()
`var(x)` returns the variance of the vector
`sd(x)` returns the standard deviation
`min(x)` returns the min value
`max(x)` returns the max value

# Numeric Function
`is.numeric(x)` returns TRUE/FALSE checking for numeric values
`is.integer(x)` works like you would expect
- to assign a value as an integer, you need to append an L (see below)


```{r}
a <- c(1, 2, 3, 4, 5)
print(length(a))

# integers must have an L appended to be truly integer data type
print(is.integer(5))
print(is.integer(5L))
```

# Dates Data Types
- Numerous types

#### Data stored as number of days (date) or number of seconds (POSIXct) since 1/1/1970
- Date
  - stores just a date
- POSIXct
  - stores date and time
  
## Date/Time Packages
- lubridate
- chron


```{r}
date1 <- as.Date('2020-04-06')
date2 <- as.POSIXct('2020-04-06 11:45')
print(class(date1))
print(date1)
print(class(date2))
print(date2)
print(as.numeric(date1))
print(as.numeric(date2))
```

# Logical (Boolean) Data Type
TRUE = 1
FALSE = 0

`is.logical(x)` returns TRUE/FALSE depending on whether x is of logical data type

T and F can also be used, but this is not best practice as these are variables that can be overwritten


```{r}

```

# Vectors
Vectors are like numpy arrays: collection of elements that must all be the same type.
- However, vectors do not have dimensions, so basically it's a list


- vector operations occur on every element in the vector
  - multiply a vector by a scalar, and every element is multiplied
  
- concatenate (combine) using `c(element list)` or you can specify a range of numbers using `start_num:stop_num` e.g. `1:10`

- vector operations on vectors of the same length will apply to each corresponding element

- use the `length(v)` to return the number of objects in the vector

- see *Conditionals as Selectors* section below for using booleans on vectors to create masks

- `any` vs `all`
  - `any(condition)` will return TRUE/FALSE if any of the objects meet the specified condition
  - `all(condition)` every element must pass


```{r}
# vector examples
v1 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
v2 <- -5:4

print(v1)
print(v2)
cat('\n') # print a line break
print(v1 * 2)
print(v1 + v2)
cat('\n')
print(any(v1>5))
print(all(v1>5))
print(v1 > 5)
```
```{r}
# selecting vector elements
print(v1[3]) # R is 1 indexed
print(v2[3]) 
cat('\n')
print(v1[3:6]) # unlike python, 6 is selected
# print(v1[:7]) # throws an error
# print(v1[5:]) # throws an error
print(v1[c(3, 6)]) # selects on certain elements
```

# Naming Vector Elements
- Sort of like a python dictionary


```{r}
# name elements in a vector (like python dictionary)
w <- c(First='a', Second='b', Third='c')
print(w)
print(names(w)) # print out the element names
cat('\n')

# can assign names after defining a vector
z <- c('four', 'five', 'six')
names(z) <- c('Number of shoes', 'Number of socks', 'Number of toes')
print(z)

```

# Factors and Vectors
- factors are basically like categories
- turning a vector of objects into a factor vector will assign each unique value an integer that refers to that item
- it also stores a list of the unique items

`as.factor(x)` is used to create a factor vector

## Can Set Ordered Levels
`factor(x=c('First', 'Second', 'Third', 'Second', 'Third', 'First'),
          levels=c('First', 'Second', 'Third')
          ordered=TRUE)`


```{r}
vec <- c('MBU', 'SIUF', 'AWR', 'SIUF', 'AWR', 'MBU', 'SIUF')
fac.vec <- as.factor(vec)
fac.vec
cat('\n')
factor(x=c('Second', 'Second', 'First', 'Second', 'Third', 'First'),
          levels=c('First', 'Second', 'Third'),
          ordered=TRUE)
```
```{r}
as.numeric(fac.vec) # return the numeric values for each item
```

## Lists
Can hold data of different types (unlike a vector)
`list(e1, e2[, e3...])` where en are elements
`list(c(e1, e2[, e3...]))` is a single element list that contains a vector
- each element could be an integer, vector, etc.
- lists can have named items just like dataframes
  - can assign during creation or by assigning after creation (just like with df's)
  
### Creating an empty list
`emptyList <- vector(mode='list', length=n)`
  - mode specifies the type of empty object
  - n specifies the number of elements

## Selecting elements in a list
- use nested indexing
- use `[[]]` double brackets when selecting to return the object at the specified location (or with the specified name)
  - can then add additional selectors like you would while working with that object
  
## Appending to a list
Assign something to an index that doesn't exist (preferably the next index)
- use `lenght(myList)` to get the length, then add 1, and that's the next index to assign to 

```{r}

```


# Basic Commands
Single line comments # just like python
Multi-line comments in R studio Ctrl + Shift + C
`c(....)` concatenates objects separated by commas
`1:9` is the same as `c(1, 2, 3, 4, 5, 6, 7, 8, 9)`
```{r}
# this is a single line comment
```

# IMPORTANT
R is 1 indexed!
```{r}
print(a[3])
```



# Installing Packages
`install.packages('packagename')` to install a package, or just use the RStudio GUI

### Install directly from github
`library(devtools)` to load devtools library
`install_github(repo='coefplot/jaredlander')` to id the repo

# Require vs. Library
`require()` will return TRUE if it succeeds or FALSE if the package isn't found. This is useful within functions.

## Quietly
`library(coefplot, quitely=TRUE)` setting quietly=TRUE will not print out any dependencies that are also loaded (default action)

# Unloading packages
`detach('package:coefplot')` to remove/unload a library

# Double loading, calling the right package
- prefix the function with the package name
`arm::coefplot()` vs. `coefplot::coefplot`
- otherwise, the most recently loaded version will be called

# Lattice Library
`library(lattice)` to load libraries

See example plot below

```{r}
data(iris)
library(lattice)
scatter1 <- xyplot(Sepal.Length ~ Sepal.Width, group=Species, data=iris)
print(scatter1)
```


# Missing Values

`NA` and `NULL` are both missing data types


## NA is a 'Missing Value'
- it is treated like an element that is missing

`is.na(x)` will return TRUE/FALSE for each element in x

to code `NA` do NOT use '', just type NA

`na.rm = TRUE` works for many functions (sometimes included as an argument of that function), and this just omits those values

- some functions will only return NA if run on a vector with missing values

## NULL is the absence of anything
- NULL will disappear from a vector, while NA will persist

`is.null(x)` returns TRUE/FALSE for x


```{r}

```


# Conditionals

syntax is below
```{r}
if (b > c) {
  print('B is greater')
} else if (b == c) {
  print('B equals C')
} else if (c > b) {
  print('C is greater')
} else print('Nonsense')
```

# Conditionals as selectors
- can use as a selection mask just like python

`TRUE` OR `FALSE`, must be all caps
```{r}
sel <- c(T, T, F, T, T) # bad practice, T/F can be overwritten
print(a[sel])
sel2 <- c(1, 1, 0, 1, 1)
print(a[sel2])
sel3 <- c('True', 'True', 'False', 'True', 'True')
print(a[sel3])
sel4 <- c(TRUE, TRUE, FALSE, TRUE, TRUE)
print(a[sel4])
sel5 <- c(True, True, False, True, False)
print(a[sel5])
```

can use complex masks
```{r}
mask <- (iris[,2] > 3) & (iris[,5] == 'setosa')
iris[mask,]
```

# Matrices
Work like numpy arrays in that all objects must be of the same type


# Matrix functions
`matrix(e, byrow=True, nrow=3)`
- e defines the elements to be used in the matrix (array-like)
- byrow tells the function to fill by rows rather than cols
- nrow is the number of rows

## Matrix properties

`colnames(matrix_name) <- array` and `rownames(matrix_name) <- array` can be used to name the cols/rows, passing an array-like object

`nrow(mat)` returns the number of rows
`ncol(mat)` returns the number of cols
`dim(mat)` returns the dimensions (nrows, ncols) of the matrix

## Matrix summary info

`rowSums(matrix_name)` will return a sum for each row
`colSums(matrix_name)` will sum each column

## Combining matrices

`big.matrix <- cbind(m1, m2)` merges matrices together by column

`rbind()` works the same way to merge matrices row-wise

## Matrix operations

In general, operations are carried out element-wise
  - dimensions of the matrix matter for this

`A + B` will add every element of A to every element of B
  - same is true for other operations

`A == B` will return TRUE/FALSE for pairwise comparisons of each element based on index

```{r}

```

# Arrays

Are essentially multidimensional matrices

Similar to matrices, except that matrices can only have 2 dimensions

`myArray <- array(e, dim=c())`
  - create an array with e elements and dimensions specified

```{r}

```


# Built-in objects

`LETTERS` a vector of English letters
  - `LETTERS[1:10]` returns the first 10 letters of the alphabet


```{r}

```

# Functions

`?` in front of a function to access the documentation
- use back ticks around operators like `+` when calling help

`apropos(str)` is used when you want a list of functions that have the supplied character 'str' in them

### Pipes
The magrittr library allows you to pass a value as the first argument to a function using `%>%` as a pipe
- example, to count the number of NA's you can nest functions or use a pipe
  - `sum(is.na(x))`
  - `x %>% is.na %>% sum`
- can still add additional named args to functions
  - `x %>% mean(na.rm=TRUE)`
  
```{r}

```
  

# Dataframes
Constructing dataframes
`data.frame(v1[, v2...])`
- where vn are all vectors of the same length separated by commas
- can also supply names during creation
`data.frame(name1=v1[name2=v2...])`
- do not use quotes around the names
`stringsAsFactors=` is an optional arg you can specify as FALSE to prevent creating factors for character cols 

 # Dataframe Properties

## Loading built-in data
`data()` can be used to load a dataframe that comes with R
- `data(iris)` for example

## Properties of dataframes
`nrow(df)` returns the number of rows
`ncol(df)` returns the number of cols
`dim(df)` returns the dimensions (rows, cols)
`names(df)` returns the col names (vector that allows you to select items)
  - `names(df)[2]` returns the second col name
  - you can also assign names using this syntax
`rownames(df)` will return the rownames (or integer index)
  - you can also assign names using this syntax
  - setting `rownames(df) <- NULL` returns to a numbered index

## Other summary df info
`head(df[, n=])` prints the first few rows (can optinally specify how many `n`)
`tail(df[, n=])` prints the last few rows
`unique(selection)` will list all of the unique items in the specified selection `unique(df[,2])`


## Selecting df elements
Like python (except 1 indexed)
`df[1, 2]` gets the first row, second column
- can also use this to assign values `df[1, 2] <- 100`
`df[4,]` selects entire 4th row, same idea for columns, but usually would just use column name for that
`df[3, 4:5]` selects the 3rd row cols 4 through 5
`df[, 2:5]` all rows, cols 2 through 5
`df[2:4, ]` rows 2 through 4, all cols
`df[, c('name1', 'name4')]` all rows, named cols `name1` and `name4`
  - use quotes around the col names
  
Objects returned from selections
- can be dataframes, vectors, scalars, or factors (can use a factor in a dataframe)
- add arg `drop=False` to return a dataframe instead of a vector/factor

Advanced selections
`df[c(3, 5), 2]` prints values in rows 3 and 5 from col 2
  - returns a vector without col info since only one col was selected
`df[c(3, 5), 4:7]` returns a dataframe with rows 3 and 5, and cols 4 through 7
  - col names printed since multiple vectors are returned

Select entire column (vector) using `$` e.g. `df.name$column.name`

## Advance Selections

- which
  - returns only indices meeting specified condition
  - `df2000 <- df[which(df$year == 2000), ]`

```{r}

```

# Creating dummy variables (one hot encoding)
- requires the steps below
`newFactor <- factor(c('level1', 'level2'[, 'level3'...]))`
`model.matrix(~ newFactor - 1)`
`attr(,'assign')`
`attr(,'contrasts')`
`attr(,'contrasts')$newFActor

```{r}

```

# Working with Files

## Reading CSV's

`read.table(file=, header=, sep=[, stringsAsFactors=[, quote=[, colClasses=]]])`
  - `file=` specifies the file path (can be a URL or other local pathway)
    - file paths should be in quotes (or variable storing path as a string)
  - `header=` TRUE/FALSE argument as to whether or not the file contains col headers
  - `sep=` allows you to specify the delimiter as a string
    - `\t` for tab delimited
  - `stringsAsFactors` is default TRUE which converts character (string) cols to factors
    - setting this false is useful when there are many cols of this type that have many different levels (can save a lot of time)
    - could go back and change a few specific types to factors
  - `quote=` can specify the character used for enclosing cells
  - `colClasses` can specify the datatype for each col

`read.csv` is very similar except that `sep` is preset to ','



## Reading in Large Files

Two very good/fast options (neither automatically reads in char data as factors)

`read_delim` from `readr` package (based on dplyr)
  - `library(readr)`
  - `filePath <- 'my/file/path.csv'`
  - `tibble.object <- read_delim(file=filePath, delim=',')`
  - When executed, will print out all of the col names and the datatype
  
  - `read_delim` functions are return a 'tibble' which is an extension of data.frame
  
  - There are shortcut functions that are wrappers for `read_delim`
    - `read_csv`
    - `read_tsv`

`fread` from `data.table` package
  - `library(data.table)`
  - `fileURL <- 'http://www.webaddress.filepath/filename.csv'`
  - `data.table.object <- fread(input=fileURL, sep=',', header=TRUE)`
  
  - Returns a data.table object (extnesion of data.frame)

- Choice of `read_delim` or `fread` depends on whether you want to use dplyr or data.table for data manipulation



## R Binary Files

Great way to save data, variable, functions

- Binary files that represent R objects of any kind
- Can store single or multiple objects
- Cross platform (Win, Mac, Lin)

Saving Objects in RData file
- `save(a, b, c, file='path/filename.rdata')`
  - where a, b, and c are defined objects

Reading in objects
- `load('path.filename.rdata')`
  - objects are loaded as they were saved (a, b, c in this case)
  - do not assign `load` to a variable, it loads saved object names
  
saveRDS save one object in a binary file w/o its name
- `saveRDS(myObject, file='path/filename.rds')`

readRDS will load that object, and you must assign a variable
- `myObject <- readRDS('path/filename.rds')`



## Excel .xls or .xlsx Files

- readxl library
  - only works on downloaded files (cannot read urls)
    - `download.file(url='url_to_file', destfile='path/filename.xlsx, method='curl')`
      - use above to download files
  - `library(readxl)` import the library
  - `excel_sheets('path/filename.xlsx')` to print sheet names
  - `myTibble <- read_excel('path/filename.xlsx')` reads in the first sheet by default
    - returns a tibble
  - add `sheet=2` argument to `read_excel()` to read in sheet #2
    - can also used names sheets `sheet='Sheet_Name'`
    

## Reading Data from Databases

See p. 81 of 'R for Everyone'


## Data from Other Stats Programs

See p. 84 of 'R for Everyone'

```{r}

```


# Exctracting Data from Websites

p. 88 'R for Everyone'

```{r}

```


# JSON Data

jsonlite Library

- `library(jsonlite)`
- `df <- fromJSON(url)` where url is a string representing the URL path to a .json file
  - `fromJSON` attempts to parse data into a data.frame



```{r}

```


# Plotting

## Basic plots
`plot(df)` will do a pairplot of all of the variables
`plot(df$y.var ~ df$x.var)` for basic plots

- Histograms
  - `hist(df$feature, main='Main Title', xlab='X Label')`
  
- Scatterplots
  - `plot(yvar ~ xvar, data=df)`
  - `plot(xvar, yvar)` plotting without formula interface
  
- Boxplots
  - `boxplot(df$feature)`


## ggplot2

- Basic syntax
  - Can save the basics of a plot to a variable
  - can help with repeated plotting or using plot data
  - `g <- ggplot(df, aes(x=xvar, y=yvar))`
  
- Layering of plots
  - order of layers matters
    - layers added in order they are included
    - last layer is on top
  - `g <- ggplot(df, aes(x=xvar, y=var))`
  - `g <- g + ...` add more on top of g
  - `g` when finished to show the plot

- `library(ggplot2)`
  - has built-in datasets (like diamonds) you can load
    - `data(diamonds)`
    - `data()` will inform you which datasets can be loaded
  
- Common plot functions
  - `geom_point`
  - `geom_line`
    - if plotting 1 line, may have to add `group=1` arg to `aes()` function
  - `geom_histogram`
  - `geom_density` like histogram but density plot instead
  - `geom_boxplot`
  - `geom_violin`

  
- Split plots by variables functions  
  - `facet_wrap`
    - takes the levels of a variables, divides into separate small plots for each level, placement has no meaning
    - `... + facet_wrap(~var.name)`
      - can supply two vars like with `facet_grid` below
  - `facet_grid`
    - like facet_wrap but assigns all levels of a variable to either a row or column
    - `... + facet_grid(yvar~xvar)`
    - would create a separate plot for every combo of yvar/xvar
  
- Common arguments for common functions
  - `aes()` 
    - aesthetic function
    - supply to `ggplot()` or to `geom_...`
      - sometimes both
    - it's a function supplied as an argument
    - as arg of `ggplot()`
      - supply your `x=` and `y=` args here
    - as arg of `geom_...`
      - can supply `x=` for geom_density/geom_histogram
      - supply your `color`, `fill`
  - `fill=` 
    - set a fill for histograms/points etc.
    - arg of `geom_density()` not of `aes()`
  - `color=` 
    - arg of `aes()`
    - use a variable to color categorical variables
    - `color=feature.name`
    - `color=factor(feature.name)` to ensure it's categorical
    - legend added automatically
    - see Axis/Legend formatting for more options
  - `group=`
    - arg of `aes()`
  
    
- Histograms and Densities
  - `ggplot(data=df) + geom_histogram(aes(x=feature))`
    - where `feature` is a variable in data.frame `df`
  - `ggplot(data=df) + geom_density(aes(x=feature), fill='gray50')`
    - use this for density plot
    
- Scatterplots
  - `ggplot(df, aes(x=xvar, y=yvar)) + geom_point()`
    - x and y vars are args of the `aes` function
    - add `geom_point()` to plot points for the scatterplot
    
- Boxplots
  - Must add an x aesthetic for univariate plots
    - `ggplot(df, aes(y=univariate.var, x=1)) + geom_boxplot()`
  - Include x variable for multiple boxplots for diff x categories
    - `ggplot(df, aes(y=yvar, x=xcatvar)) + geom_boxplot()`

- Violin Plots
  - work just like boxplots
  - use `+ geom_violin()` instead

## Axis/Legend Formatting

- `library(scales)`
- `+ scale_color_discrete(name='Legend Name')`
  - when the `color` arg is used to define the legend
- `+ scale_y_continuous(labels=comma)`
  - add commas to y axis numbers
- `+ labs(title='Main Title', x='x Label', y='y Label')`

## Plotting Themes (ggthemes)

Add as last layer

- `library(ggthemes)`

- Economist Theme
  - `g <- g + theme_economist() + scale_colour_economist()`
  
- Excel Theme
  - `g <- g + them_excel() + scale_colour_excel()`
  
- Tufte Theme
  - `g <- g + theme_tufte()`
  
- Wall street Journal Theme
  - `g <- g + theme_wsj()`


```{r}

```


# Working with Dates/Times and Datetimes

## lubridate

- `library(lubridate)`
- `df$year <- year(df$date)` get the year
- `df$month <- month(df$date, label=TRUE)`
  - `label=TRUE` returns name of month instead of number